---
layout: post
title: 실시간 스트리밍 프로토콜 - RTSP
comments: true
categories: [ComputerVision]
---

RTSP (실시간 스트리밍 프로토콜)는 실시간 속성을 사용하여 데이터 전달을 제어하기위한 응용 프로그램 수준 프로토콜입니다. RTSP는 확장 가능한 프레임 워크를 제공하여 오디오 및 비디오와 같은 실시간 데이터를 온 디맨드 방식으로 제어 할 수 있습니다. 데이터 소스에는 라이브 데이터 피드와 저장된 클립이 모두 포함될 수 있습니다. 이 프로토콜은 여러 데이터 전달 세션을 제어하고 UDP, 멀티 캐스트 UDP 및 TCP와 같은 전달 채널을 선택하는 수단을 제공하고 RTP (RFC 1889)를 기반으로 전달 메커니즘을 선택하는 수단을 제공하기위한 것입니다.

<hr/>

### 1. Introduction

#### 1.1 Purpose


RTSP (Real-Time Streaming Protocol)는 오디오 및 비디오와 같은 연속 미디어의 단일 또는 여러 시간 동기화 스트림을 설정하고 제어합니다. 연속 미디어 스트림을 제어 스트림과 인터리빙하는 것이 가능하지만 일반적으로 연속 스트림 자체를 전달하지는 않습니다 (섹션 10.12 참조). 즉, RTSP는 멀티미디어 서버의 "네트워크 원격 제어"역할을합니다.    
제어 될 스트림 세트는 프리젠 테이션 설명에 의해 정의된다. 이 각서는 프레젠테이션 설명에 대한 형식을 정의하지 않습니다.    

RTSP 연결에 대한 개념은 없습니다. 대신 서버는 식별자로 레이블이 지정된 세션을 유지 관리합니다. RTSP 세션은 TCP 연결과 같은 전송 수준 연결과 연결되어 있지 않습니다. RTSP 세션 동안 RTSP 클라이언트는 RTSP 요청을 발행하기 위해 서버에 대한 많은 안정적인 전송 연결을 열고 닫을 수 있습니다. 또는 UDP와 같은 비 연결 전송 프로토콜을 사용할 수 있습니다. 

RTSP에 의해 제어되는 스트림은 RTP를 사용할 수 있지만 [1] RTSP의 작동은 연속 미디어를 운반하는 데 사용되는 전송 메커니즘에 의존하지 않습니다. 프로토콜은 HTTP / 1.1 [2]와 구문 및 동작면에서 의도적으로 유사하므로 대부분의 경우 HTTP에 대한 확장 메커니즘을 RTSP에 추가 할 수 있습니다. 그러나 RTSP는 HTTP와 여러 가지 중요한 측면에서 다릅니다.


* RTSP는 여러 가지 새로운 방법을 도입했으며 프로토콜 식별자가 다릅니다.      
* RTSP 서버는 HTTP의 상태 비 저장 특성과 달리 거의 모든 경우에 기본적으로 상태를 유지해야합니다.      
* RTSP 서버와 클라이언트 모두 요청을 발행 할 수 있습니다.      
* 데이터는 다른 프로토콜에 의해 대역 외에서 수행됩니다. (예외가 있습니다.)      
* RTSP는 현재 HTML 국제화 노력에 따라 ISO 8859-1 대신 ISO 10646 (UTF-8)을 사용하도록 정의되어 있습니다 [3].      
* Request-URI는 항상 절대 URI를 포함합니다. 과거의 실수와의 역 호환성으로 인해 HTTP / 1.1 [2]는 요청에서 절대 경로 만 전달하고 호스트 이름을 별도의 헤더 필드에 넣습니다.     
 따라서 하나의 IP 주소를 가진 단일 호스트가 여러 문서 트리를 호스팅하는 "가상 호스팅"이 더 쉬워집니다.    

이 프로토콜은 다음 작업을 지원합니다.

미디어 서버에서 미디어 검색 :         

      클라이언트는 HTTP 또는 다른 방법을 통해 프리젠 테이션 설명을 요청할 수 있습니다. 프리젠 테이션이 멀티 캐스트 인 경우 프리젠 테이션 설명에는 연속 매체에 사용될 멀티 캐스트 주소 및 포트가 포함됩니다. 프리젠 테이션이 유니 캐스트를 통해 클라이언트에게만 전송되는 경우 클라이언트는 보안상의 이유로 대상을 제공합니다.    

미디어 서버를 회의에 초대 :           

      미디어 서버는 프리젠 테이션에서 미디어를 재생하거나 프리젠 테이션에 미디어의 전부 또는 일부를 기록하기 위해 기존 컨퍼런스에 참여하도록 "초대"될 수 있습니다. 이 모드는 분산 교육 응용 프로그램에 유용합니다. 회의의 여러 당사자가 "리모콘 버튼을 누르는"순서로 전환 할 수 있습니다.    

기존 프리젠 테이션에 미디어 추가 :

      특히 라이브 프리젠 테이션의 경우 서버가 클라이언트에게 추가 미디어를 사용할 수있게 할 수있는 경우 유용합니다.   

 RTSP 요청은 HTTP / 1.1에서와 같이 프록시, 터널 및 캐시에 의해 처리 될 수있다 [2].

<hr/>

#### 1.2 Requirements

이 문서의 핵심 단어 "MUST", "MUST NOT", "필수", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY"및 "OPTIONAL" RFC 2119 [4]에 설명 된대로 해석해야합니다.

<hr/>

#### 1.3 Terminology

일부 용어는 HTTP / 1.1에서 채택되었습니다 [2]. 여기에 나열되지 않은 용어는 HTTP / 1.1에서와 같이 정의됩니다.

집계 제어 :           

      서버에서 단일 타임 라인을 사용하여 여러 스트림을 제어합니다. 오디오 / 비디오 피드의 경우 이는 클라이언트가 단일 재생 또는 일시 중지 메시지를 발행하여 오디오 및 비디오 피드를 모두 제어 할 수 있음을 의미합니다.    

회의:           

      "멀티"가 1 이상의 것을 의미하는 다자간 멀티미디어 프리젠 테이션.    

고객:           

      클라이언트는 미디어 서버에서 연속 미디어 데이터를 요청합니다.    

연결:           

      통신을 위해 두 프로그램간에 설정된 전송 계층 가상 회로.    

컨테이너 파일 :           

      여러 미디어 스트림을 포함 할 수있는 파일로, 함께 재생할 때 종종 프리젠 테이션을 구성합니다. 컨테이너 파일의 개념은 프로토콜에 포함되어 있지 않지만 RTSP 서버는 이러한 파일에 대한 종합적인 제어를 제공 할 수 있습니다.   

연속 미디어 :           

      소스와 싱크 사이에 타이밍 관계가있는 데이터 즉, 싱크는 소스에 존재하는 타이밍 관계를 재현해야합니다. 연속 미디어의 가장 일반적인 예는 오디오 및 모션 비디오입니다. 연속 미디어는 소스 (source)와 싱크 (sink) 사이의 "타이밍"타이밍 관계가있는 실시간 (대화식) 또는 관계가 덜 엄격한 스트리밍 (재생) 일 수 있습니다.

실재:           

      요청 또는 응답의 페이로드로 전송 된 정보입니다. 엔터티는 섹션 8에 설명 된대로 엔터티 헤더 필드 형식의 메타 정보와 엔터티 본문 형식의 콘텐츠로 구성됩니다.    

미디어 초기화 :           

      데이터 유형 / 코덱 별 초기화 여기에는 클럭 속도, 색상 표 등이 포함됩니다. 미디어 스트림 재생을 위해 클라이언트가 필요로하는 전송 독립적 정보는 스트림 설정의 미디어 초기화 단계에서 발생합니다.    

미디어 매개 변수 :           
      
      스트림 재생 전 또는 도중에 변경 될 수있는 미디어 유형에 특정한 매개 변수입니다.    

미디어 서버 :           

      하나 이상의 미디어 스트림에 대한 재생 또는 녹화 서비스를 제공하는 서버. 프레젠테이션 내의 다른 미디어 스트림은 다른 미디어 서버에서 시작될 수 있습니다. 미디어 서버는 프리젠 테이션이 호출 된 웹 서버와 동일하거나 다른 호스트에 상주 할 수 있습니다.

미디어 서버 간접 :           

      미디어 클라이언트를 다른 미디어 서버로 리디렉션    

(미디어) 스트림 :           

      단일 미디어 인스턴스 (예 : 오디오 스트림 또는 비디오 스트림과 단일 화이트 보드 또는 공유 응용 프로그램 그룹) RTP를 사용할 때 스트림은 RTP 세션 내의 소스에서 생성 된 모든 RTP 및 RTCP 패킷으로 구성됩니다. 이는 DSM-CC 스트림 ([5])의 정의와 동일합니다.    

메시지:           

      RTSP 통신의 기본 단위는 섹션 15에 정의 된 구문과 일치하고 연결 또는 비 연결 프로토콜을 통해 전송되는 구조화 된 옥텟 시퀀스로 구성됩니다.    

참가자:           

      회의 회원. 참가자는 머신, 예를 들어 미디어 레코드 또는 재생 서버 일 수있다. 

표시:           

      아래 정의 된 프리젠 테이션 설명을 사용하여 완전한 미디어 피드로 클라이언트에 제시된 하나 이상의 스트림 세트. 대부분의 경우 RTSP 컨텍스트에서 이는 해당 스트림의 집계 제어를 의미하지만 반드시 그럴 필요는 없습니다.   

프리젠 테이션 설명 :           

      프리젠 테이션 설명은 인코딩 세트, 네트워크 주소 및 컨텐츠에 관한 정보와 같은 프리젠 테이션 내의 하나 이상의 미디어 스트림에 관한 정보를 포함한다. SDP (RFC 2327 [6])와 같은 다른 IETF 프로토콜은 라이브 프레젠테이션에 "세션"이라는 용어를 사용합니다. 프리젠 테이션 디스크립션은 세션 디스크립션 포맷 (SDP)을 포함하지만 이에 한정되지 않는 몇몇 상이한 포맷을 취할 수있다.    

응답:           

      RTSP 응답. HTTP 응답을 의미하는 경우 명시 적으로 표시됩니다.    

의뢰:           

      RTSP 요청 HTTP 요청을 의미하는 경우 명시 적으로 표시됩니다.    

RTSP 세션 :           

      완전한 RTSP "트랜잭션"(예 : 영화보기)           
      세션은 일반적으로 클라이언트가 연속 미디어 스트림 (SETUP)에 대한 전송 메커니즘을 설정하고, PLAY 또는 RECORD로 스트림을 시작하고, TEARDOWN으로 스트림을 닫는 것으로 구성됩니다.    

전송 초기화 :           

      클라이언트와 서버 간의 전송 정보 (예 : 포트 번호, 전송 프로토콜) 협상

<hr/>

#### 1.4 Protocol Properties

RTSP에는 다음과 같은 속성이 있습니다.    

확장 가능 :           

      RTSP에 새로운 방법과 매개 변수를 쉽게 추가 할 수 있습니다.    
파싱하기 쉽다 :           

      RTSP는 표준 HTTP 또는 MIME 파서로 파싱 할 수 있습니다.    
안전한:           

      RTSP는 웹 보안 메커니즘을 재사용합니다. 기본 (RFC 2068 [2, 섹션 11.1]) 및 다이제스트 인증 (RFC 2069 [8])과 같은 모든 HTTP 인증 메커니즘이 직접 적용됩니다. 전송 또는 네트워크 계층 보안 메커니즘을 재사용 할 수도 있습니다.    
운송 독립 :           

      RTSP는 신뢰할 수없는 데이터 그램 프로토콜 (UDP) (RFC 768 [9]), 신뢰할 수있는 데이터 그램 프로토콜 (RDP, RFC 1151, 널리 사용되지 않는 [10]) 또는 TCP (RFC 793 [11] 응용 프로그램 수준의 안정성을 구현합니다.    
다중 서버 가능 :           

      프레젠테이션 내의 각 미디어 스트림은 다른 서버에 상주 할 수 있습니다. 클라이언트는 다른 미디어 서버와 여러 동시 제어 세션을 자동으로 설정합니다. 미디어 동기화는 전송 수준에서 수행됩니다.    
녹음 장치 제어 :           

      이 프로토콜은 녹화 및 재생 장치와 두 모드를 번갈아 사용할 수있는 장치 ( "VCR")를 모두 제어 할 수 있습니다.    
스트림 제어 및 회의 시작 분리 :           

      스트림 제어는 미디어 서버를 회의에 초대하는 것과는 다릅니다. 유일한 요구 사항은 전화 회의 시작 프로토콜이 고유 한 전화 회의 식별자를 제공하거나이를 만드는 데 사용될 수 있다는 것입니다. 특히 SIP [12] 또는 H.323 [13]을 사용하여 서버를 회의에 초대 할 수 있습니다.

전문 분야에 적합 :           

      RTSP는 SMPTE 타임 스탬프를 통해 프레임 수준의 정확도를 지원하여 원격 디지털 편집이 가능합니다.    
프리젠 테이션 설명 중립 :           

      이 프로토콜은 특정 프레젠테이션 설명이나 메타 파일 형식을 강요하지 않으며 사용할 형식의 형식을 전달할 수 있습니다. 그러나 프리젠 테이션 설명에는 하나 이상의 RTSP URI가 포함되어야합니다.    
프록시 및 방화벽 친화적 :           
      
      프로토콜은 애플리케이션 및 전송 계층 (SOCKS [14]) 
      방화벽 모두에서 쉽게 처리해야합니다. 방화벽은 UDP 미디어 스트림의 "홀"을 열기 위해 SETUP 방법을 이해해야합니다.    
HTTP 친화적 :

      합리적인 경우 RTSP는 HTTP 개념을 재사용하므로 기존 인프라를 재사용 할 수 있습니다. 이 인프라에는 레이블을 컨텐츠와 연관시키기위한 PICS (Internet Content Selection 용 플랫폼 [15,16])가 포함되어 있습니다. 그러나 연속 미디어를 제어하려면 대부분의 경우 서버 상태가 필요하기 때문에 RTSP는 HTTP에 메소드를 추가하지 않습니다.    

적절한 서버 제어 :           
      
      클라이언트가 스트림을 시작할 수 있으면 스트림을 중지 할 수 있어야합니다. 클라이언트가 스트림을 중지 할 수없는 방식으로 서버가 클라이언트로 스트리밍을 시작해서는 안됩니다.    
운송 협상 :           
      
      클라이언트는 실제로 연속 미디어 스트림을 처리해야하기 전에 전송 방법을 협상 할 수 있습니다.

기능 협상 :           

      기본 기능을 사용하지 않으면 클라이언트가 구현하지 않을 메소드를 결정하는 명확한 메커니즘이 있어야합니다. 이를 통해 클라이언트는 적절한 사용자 인터페이스를 제시 할 수 있습니다. 예를 들어, 탐색이 허용되지 않으면 사용자 인터페이스는 슬라이딩 위치 표시기의 이동을 허용하지 않아야합니다.      

RTSP의 초기 요구 사항은 다중 클라이언트 기능이었습니다. 그러나 더 나은 접근 방식은 프로토콜이 다중 클라이언트 시나리오에 쉽게 확장 될 수 있도록하는 것입니다. 스트림 식별자는 여러 제어 스트림에서 사용될 수 있으므로 "원격 통과"가 가능합니다. 이 프로토콜은 여러 클라이언트가 액세스를 협상하는 방법을 다루지 않습니다. 이것은 "사회적 프로토콜"또는 다른 층 제어 메커니즘에 맡겨져 있습니다.
<hr/>

#### 1.5 Extending RTSP

모든 미디어 서버가 동일한 기능을 갖지는 않기 때문에 필요에 따라 미디어 서버는 서로 다른 요청 집합을 지원합니다. 예를 들면 다음과 같습니다.      

* 서버는 재생 만 가능하므로 RECORD 요청을 지원할 필요가 없습니다.      
* 서버는 실시간 이벤트 만 지원하는 경우 탐색 (절대 위치 지정)을 수행하지 못할 수 있습니다. 
* 일부 서버는 스트림 매개 변수 설정을 지원하지 않으므로 GET_PARAMETER 및 SET_PARAMETER를 지원하지 않을 수 있습니다.    

서버는 12 장에서 설명한 모든 헤더 필드를 구현해야한다.    
서버의 불가능 성을 요구하지 않는 것은 프리젠 테이션 설명의 작성자에게 달려 있습니다. 이 상황은 HTTP / 1.1 [2]와 유사하며 [H19.6]에 설명 된 방법이 모든 서버에서 지원되지는 않습니다.    RTSP는 지원되는 변경 정도에 따라 다음과 같은 세 가지 방법으로 확장 될 수 있습니다.

* Existing methods can be extended with new parameters, as long as
       these parameters can be safely ignored by the recipient. (This is
       equivalent to adding new parameters to an HTML tag.) If the
       client needs negative acknowledgement when a method extension is
       not supported, a tag corresponding to the extension may be added
       in the Require: field (see Section 12.32).
* New methods can be added. If the recipient of the message does
       not understand the request, it responds with error code 501 (Not
       implemented) and the sender should not attempt to use this method
       again. A client may also use the OPTIONS method to inquire about
       methods supported by the server. The server SHOULD list the
       methods it supports using the Public response header.
* A new version of the protocol can be defined, allowing almost all
       aspects (except the position of the protocol version number) to
       change.
<hr/>

#### 1.6 Overall Operation

   Each presentation and media stream may be identified by an RTSP URL.
   The overall presentation and the properties of the media the
   presentation is made up of are defined by a presentation description
   file, the format of which is outside the scope of this specification.
   The presentation description file may be obtained by the client using

   HTTP or other means such as email and may not necessarily be stored
   on the media server.

   For the purposes of this specification, a presentation description is
   assumed to describe one or more presentations, each of which
   maintains a common time axis. For simplicity of exposition and
   without loss of generality, it is assumed that the presentation
   description contains exactly one such presentation. A presentation
   may contain several media streams.

   The presentation description file contains a description of the media
   streams making up the presentation, including their encodings,
   language, and other parameters that enable the client to choose the
   most appropriate combination of media. In this presentation
   description, each media stream that is individually controllable by
   RTSP is identified by an RTSP URL, which points to the media server
   handling that particular media stream and names the stream stored on
   that server. Several media streams can be located on different
   servers; for example, audio and video streams can be split across
   servers for load sharing. The description also enumerates which
   transport methods the server is capable of.

   Besides the media parameters, the network destination address and
   port need to be determined. Several modes of operation can be
   distinguished:

   Unicast:
   
          The media is transmitted to the source of the RTSP request,
          with the port number chosen by the client. Alternatively, the
          media is transmitted on the same reliable stream as RTSP.

   Multicast, server chooses address:
   
          The media server picks the multicast address and port. This is
          the typical case for a live or near-media-on-demand
          transmission.

   Multicast, client chooses address:

          If the server is to participate in an existing multicast
          conference, the multicast address, port and encryption key are
          given by the conference description, established by means
          outside the scope of this specification.
<hr/>

#### 1.7 RTSP States

   RTSP controls a stream which may be sent via a separate protocol,
   independent of the control channel. For example, RTSP control may
   occur on a TCP connection while the data flows via UDP. Thus, data
   delivery continues even if no RTSP requests are received by the media

   server. Also, during its lifetime, a single media stream may be
   controlled by RTSP requests issued sequentially on different TCP
   connections. Therefore, the server needs to maintain "session state"
   to be able to correlate RTSP requests with a stream. The state
   transitions are described in Section A.

   Many methods in RTSP do not contribute to state. However, the
   following play a central role in defining the allocation and usage of
   stream resources on the server: SETUP, PLAY, RECORD, PAUSE, and
   TEARDOWN.

   SETUP:

          Causes the server to allocate resources for a stream and start
          an RTSP session.

   PLAY and RECORD:

          Starts data transmission on a stream allocated via SETUP.

   PAUSE:

          Temporarily halts a stream without freeing server resources.

   TEARDOWN:

          Frees resources associated with the stream. The RTSP session
          ceases to exist on the server.

RTSP methods that contribute to state use the Session header
          field (Section 12.37) to identify the RTSP session whose state
          is being manipulated. The server generates session identifiers
          in response to SETUP requests (Section 10.4).

<hr/>

#### 1.8 Relationship with Other Protocols

   RTSP has some overlap in functionality with HTTP. It also may
   interact with HTTP in that the initial contact with streaming content
   is often to be made through a web page. The current protocol
   specification aims to allow different hand-off points between a web
   server and the media server implementing RTSP. For example, the
   presentation description can be retrieved using HTTP or RTSP, which
   reduces roundtrips in web-browser-based scenarios, yet also allows
   for standalone RTSP servers and clients which do not rely on HTTP at
   all.

   However, RTSP differs fundamentally from HTTP in that data delivery
   takes place out-of-band in a different protocol. HTTP is an
   asymmetric protocol where the client issues requests and the server
   responds. In RTSP, both the media client and media server can issue
   requests. RTSP requests are also not stateless; they may set
   parameters and continue to control a media stream long after the


   request has been acknowledged.

Re-using HTTP functionality has advantages in at least two areas,
     namely security and proxies. The requirements are very similar, so
     having the ability to adopt HTTP work on caches, proxies and
     authentication is valuable.

   While most real-time media will use RTP as a transport protocol, RTSP
   is not tied to RTP.

   RTSP assumes the existence of a presentation description format that
   can express both static and temporal properties of a presentation
   containing several media streams.

<hr/>

### 2. Notational Conventions

많은 정의와 구문이 HTTP / 1.1과 동일하기 때문에이 사양은 정의가 복사 된 것이 아니라 정의 된 섹션만을 가리 킵니다. 간결성을 위해 [HX.Y]는 현재 HTTP / 1.1 사양 (RFC 2068 [2])의 X.Y 섹션을 참조하도록 취해집니다.


이 문서에 명시된 모든 메커니즘은 [H2.1]에서 사용 된 것과 유사한 산문 및 확장 된 Backus-Naur 양식 (BNF)으로 설명됩니다. 이 RTSP 사양이 쉼표로 구분 된 목록에 대해 "1 #"표기법을 유지한다는 점을 제외하고는 RFC 2234 [17]에 자세히 설명되어 있습니다.    


이 메모에서는 들여 쓰기 및 더 작은 유형의 단락을 사용하여 배경과 동기를 부여합니다. 이것은 사양의 공식화에 관여하지 않은 독자들에게 왜 그것이 RTSP에있는 방식인지에 대한 이해를 제공하기위한 것입니다.
<hr/>

### 3. Protocol Parameters

#### 3.1 RTSP Version

   [H3.1] applies, with HTTP replaced by RTSP.
<hr/>

#### 3.2 RTSP URL

"rtsp"및 "rtspu"체계는 RTSP 프로토콜을 통해 네트워크 리소스를 참조하는 데 사용됩니다. 이 섹션에서는 RTSP URL의 체계 별 구문 및 의미를 정의합니다.

```
   rtsp_URL  =   ( "rtsp:" | "rtspu:" )
                 "//" host [ ":" port ] [ abs_path ]
   host      =   <A legal Internet host domain name of IP address
                 (in dotted decimal form), as defined by Section 2.1


                 of RFC 1123 \cite{rfc1123}>
   port      =   *DIGIT

   abs_path is defined in [H3.2.1].
```

현재 해석과 RTSP 서버에 대한 해석을 통해 조각 및 쿼리 식별자는 잘 정의 된 의미가 없습니다.    
rtsp 구성표는 인터넷, TCP 내에서 신뢰할 수있는 프로토콜을 통해 명령을 실행해야하지만 rtspu 구성표는 신뢰할 수없는 프로토콜 (인터넷 내에서 UDP)을 식별합니다.  

포트가 비어 있거나 제공되지 않으면 포트 554가 사용됩니다. 의미는 식별 된 자원이 해당 호스트 포트에서 TCP (체계 "rtsp") 연결 또는 UDP (체계 "rtspu") 패킷을 수신하는 서버에서 RTSP에 의해 제어 될 수 있으며 자원의 Request-URI는 rtsp_URL입니다.
URL에서 IP 주소 사용은 가능하면 피해야합니다 (RFC 1924 [19] 참조).    

프리젠 테이션 또는 스트림은 URL의 문자 세트 및 이스케이프 규칙 [H3.2] (RFC 1738 [20])을 사용하여 텍스트 미디어 식별자로 식별됩니다. URL은 스트림 또는 스트림 집합, 즉 프리젠 테이션을 의미 할 수 있습니다. 따라서 섹션 10에 설명 된 요청은 전체 프리젠 테이션 또는 프리젠 테이션 내의 개별 스트림에 적용될 수 있습니다. 일부 요청 방법은 프리젠 테이션이 아닌 스트림에만 적용 할 수 있으며 그 반대도 마찬가지입니다.

   For example, the RTSP URL: 

     rtsp://media.example.com:554/twister/audiotrack

"twister"프레젠테이션 내 오디오 스트림을 식별합니다.이 스트림은 TCP를 통해 호스트 media.example.com의 포트 554로 발행 된 RTSP 요청을 통해 제어 할 수 있습니다.

   Also, the RTSP URL:

     rtsp://media.example.com:554/twister

오디오 및 비디오 스트림으로 구성 될 수있는 프레젠테이션 "트위스터"를 식별합니다.    
이것은 URL에서 스트림을 참조하는 표준 방법을 의미하지 않습니다. 프리젠 테이션 설명은 프리젠 테이션의 계층 적 관계와 개별 스트림의 URL을 정의합니다. 

프리젠 테이션 기술은 스트림 "a.mov"및 전체 프리젠 테이션을 "b.mov"로 명명 할 수있다.    
RTSP URL의 경로 구성 요소는 클라이언트에게 불투명하며 서버의 특정 파일 시스템 구조를 의미하지 않습니다.      

이 디커플링을 사용하면 URL의 체계를 간단히 바꾸어 프레젠테이션 설명을 비 RTSP 미디어 제어 프로토콜과 함께 사용할 수도 있습니다.

<hr/>

#### 3.3 Conference Identifiers

회의 식별자는 RTSP에 대해 불투명하며 표준 URI 인코딩 방법을 사용하여 인코딩됩니다 (즉, LWS는 %로 이스케이프됩니다). 옥텟 값을 포함 할 수 있습니다. 회의 식별자는 전역 적으로 고유해야합니다. H.323의 경우 conferenceID 값이 사용됩니다.  

      conference-id =   1*xchar

회의 식별자는 RTSP 세션이 미디어 서버가 참여하는 멀티미디어 회의에서 매개 변수를 얻을 수 있도록하는 데 사용됩니다. 이러한 회의는이 사양의 범위를 벗어난 프로토콜 (예 : H.323 [13] 또는 SIP [12])에 의해 생성됩니다. 예를 들어 RTSP 클라이언트는 전송 정보를 명시 적으로 제공하는 대신 미디어 서버에 회의 설명의 값을 대신 사용하도록 요청합니다.
<hr/>

#### 3.4 Session Identifiers

세션 식별자는 임의 길이의 불투명 문자열입니다. 선형 공백은 URL 이스케이프되어야합니다. 세션 식별자는 무작위로 선택해야하며 추측하기 어렵게하려면 길이가 8 옥텟 이상이어야합니다. (섹션 16 참조)

     session-id   =   1*( ALPHA | DIGIT | safe )
<hr/>

#### 3.5 SMPTE Relative Timestamps
SMPTE 상대 타임 스탬프는 클립의 시작과 관련된 시간을 나타냅니다. 상대 타임 스탬프는 프레임 레벨 액세스 정확도를위한 SMPTE 타임 코드로 표현됩니다. 타임 코드의 형식은 시간 : 분 : 초 : 프레임. 서브 프레임이며 클립의 시작 부분에 원점이 있습니다. 기본 smpte 형식은 "SMPTE 30 drop"형식이며 프레임 속도는 초당 29.97 프레임입니다. "smpte time"의 대체 사용을 통해 다른 SMPTE 코드 (예 : "SMPTE 25")가 지원 될 수 있습니다. 시간 값의 "프레임"필드의 값은 0-29로 가정 할 수 있습니다. 초당 30에서 29.97 프레임의 차이는 매 10 분마다를 제외하고 모든 분의 처음 두 프레임 인덱스 (값 00 및 01)를 삭제하여 처리됩니다. . 프레임 값이 0이면 생략 될 수 있습니다. 서브 프레임은 100 분의 1 프레임으로 측정됩니다.

   ```
   smpte-range  =   smpte-type "=" smpte-time "-" [ smpte-time ]
   smpte-type   =   "smpte" | "smpte-30-drop" | "smpte-25"
                                   ; other timecodes may be added
   smpte-time   =   1*2DIGIT ":" 1*2DIGIT ":" 1*2DIGIT [ ":" 1*2DIGIT ]
                       [ "." 1*2DIGIT ]


   Examples:
     smpte=10:12:33:20-
     smpte=10:07:33-
     smpte=10:07:00-10:07:33:05.01
     smpte-25=10:07:00-10:07:33:05.01
  ```
<hr/>

#### 3.6 Normal Play Time
정상 재생 시간 (NPT)은 프리젠 테이션의 시작에 대한 스트림 절대 위치를 나타냅니다. 타임 스탬프는 소수로 구성됩니다. 소수점 왼쪽 부분은 초 또는 시간, 분 및 초로 표현 될 수 있습니다. 소수점 오른쪽 부분은 1 초의 분수를 측정합니다.    

프리젠 테이션의 시작은 0.0 초에 해당합니다. 음수 값은 정의되어 있지 않습니다. 특수 상수는 이제 실시간 이벤트의 현재 순간으로 정의됩니다. 라이브 이벤트에만 사용할 수 있습니다.   

NPT는 DSM-CC에서와 같이 정의됩니다. "직관적으로 NPT는 시청자가 프로그램과 연결하는 시계입니다. VCR에 디지털로 표시되는 경우가 많습니다. NPT는 일반 재생 모드 (스케일 = 1) 일 때 정상적으로 진행되고 더 빠르게 진행됩니다. 빠른 스캔 포워드 (높은 포지티브 스케일 비율) 일 때의 속도, 스캔 역방향 (높은 네거티브 스케일 비율) 일 때 감소하고 일시 정지 모드에서 고정됩니다. NPT는 (논리적으로) SMPTE 타임 코드와 같습니다. " [5]


      npt-range    =   ( npt-time "-" [ npt-time ] ) | ( "-" npt-time )
      npt-time     =   "now" | npt-sec | npt-hhmmss
      npt-sec      =   1*DIGIT [ "." *DIGIT ]
      npt-hhmmss   =   npt-hh ":" npt-mm ":" npt-ss [ "." *DIGIT ]
      npt-hh       =   1*DIGIT     ; any positive number
      npt-mm       =   1*2DIGIT    ; 0-59
      npt-ss       =   1*2DIGIT    ; 0-59


      Examples:
      npt=123.45-125
      npt=12:05:35.3-
      npt=now-

이 구문은 ISO 8601을 준수합니다. npt-sec 표기법은 자동 생성, ntp-hhmmss 표기법, 인간 독자가 사용하도록 최적화되어 있습니다. "현재"상수를 사용하면 클라이언트가 저장되거나 시간 지연된 버전이 아닌 라이브 피드를 받도록 요청할 수 있습니다. 이 경우에는 절대 시간이나 0 시간이 적절하지 않기 때문에 필요합니다.
<hr/>

#### 3.7 Absolute Time

절대 시간은 UTC (GMT)를 사용하여 ISO 8601 타임 스탬프로 표현됩니다. 초의 분수가 표시 될 수 있습니다.


     utc-range    =   "clock" "=" utc-time "-" [ utc-time ]
     utc-time     =   utc-date "T" utc-time "Z"
     utc-date     =   8DIGIT                    ; < YYYYMMDD >
     utc-time     =   6DIGIT [ "." fraction ]   ; < HHMMSS.fraction >


     Example for November 8, 1996 at 14h37 and 20 and a quarter seconds
     UTC:


     19961108T143720.25Z
<hr/>

#### 3.8 Option Tags

옵션 태그는 RTSP에서 새 옵션을 지정하는 데 사용되는 고유 식별자입니다. 이 태그는 Require (12.32 섹션) 및 Proxy-Require (12.27 섹션) 헤더 필드에 사용됩니다.    

      Syntax:
            option-tag   =   1*xchar  

새로운 RTSP 옵션을 만든 사람은 옵션에 역 도메인 이름을 접두어로 붙여야합니다.

(예 : "com.foo.mynewfeature"는 발명가가 "foo.com"에 도달 할 수있는 기능의 적절한 이름입니다). IANA (Internet Assigned Numbers Authority)의 새로운 옵션.
<hr/>

#### 3.8.1 Registering New Option Tags with IANA

   When registering a new RTSP option, the following information should
   be provided:

* Name and description of option. The name may be of any length,
       but SHOULD be no more than twenty characters long. The name MUST
       not contain any spaces, control characters or periods.
* Indication of who has change control over the option (for
       example, IETF, ISO, ITU-T, other international standardization
       bodies, a consortium or a particular company or group of
       companies);

* A reference to a further description, if available, for example
       (in order of preference) an RFC, a published paper, a patent
       filing, a technical report, documented source code or a computer
       manual;
* For proprietary options, contact information (postal and email
       address);
<hr/>

### 4. RTSP Message

RTSP는 텍스트 기반 프로토콜이며 UTF-8 인코딩 (RFC 2279 [21])으로 ISO 10646 문자 세트를 사용합니다. 회선은 CRLF로 종료되지만 수신자는 CR 및 LF를 자체적으로 회선 종결 자로 해석 할 수 있도록 준비해야합니다.      

텍스트 기반 프로토콜을 사용하면 자체 설명 방식으로 선택적 매개 변수를 쉽게 추가 할 수 있습니다. 매개 변수의 수와 명령의 빈도가 낮기 때문에 처리 효율성은 중요하지 않습니다. 텍스트 기반 프로토콜을 신중하게 수행하면 Tcl, Visual Basic 및 Perl과 같은 스크립팅 언어로 연구 프로토 타입을 쉽게 구현할 수 있습니다.      

10646 문자 집합은 까다로운 문자 집합 전환을 피하지만 US-ASCII를 사용하는 한 응용 프로그램에는 보이지 않습니다. RTCP에 사용되는 인코딩이기도합니다. ISO 8859-1은 0의 상위 8 진수로 유니 코드로 직접 변환됩니다. 가장 중요한 비트 세트를 가진 ISO 8859-1 문자는 1100001x 10xxxxxx로 표시됩니다. (RFC 2279 [21] 참조)    

RTSP 메시지는 8 비트 클린 인 모든 하위 계층 전송 프로토콜을 통해 전달 될 수 있습니다.    
요청에는 메소드, 메소드가 수행중인 오브젝트 및 메소드를 추가로 설명하는 매개 변수가 포함됩니다. 달리 언급되지 않는 한, 방법은 dem 등이다. 또한 방법은 미디어 서버에서 상태를 거의 또는 전혀 유지 관리하지 않아도되도록 설계되었습니다.

#### 4.1 Message Types

   See [H4.1]

#### 4.2 Message Headers

   See [H4.2]

#### 4.3 Message Body

   See [H4.3]
<hr/>

#### 4.4 Message Length
메시지 본문이 메시지에 포함 된 경우 해당 본문의 길이는 다음 중 하나에 의해 결정됩니다 (우선 순위 순).    

1. 메시지 본문 (예 : 1xx, 204 및 304 응답)을 포함해서는 안되는 응답 메시지는 메시지에 존재하는 엔터티 헤더 필드에 관계없이 헤더 필드 다음의 첫 번째 빈 줄로 항상 종료됩니다. (참고 : 빈 줄은 CRLF로만 구성됩니다.)    
2. Content-Length 헤더 필드 (섹션 12.14)가 존재하면, 바이트 단위의 값은 메시지 본문의 길이를 나타냅니다. 이 헤더 필드가 없으면 값은 0으로 가정됩니다.    
3. 서버가 연결을 닫습니다. 연결을 닫으면 요청 본문의 끝을 나타내는 데 사용할 수 없습니다. 서버가 응답을 다시 보낼 가능성이 없기 때문입니다.    

RTSP는 (현재) HTTP / 1.1 "청크"전송 코딩을 지원하지 않으며 ([H3.6] 참조) Content-Length 헤더 필드가 필요합니다.      

적당한 길이의 프리젠 테이션 설명이 리턴되면, 서버는 동적으로 생성 된 경우에도 길이를 판별 할 수 있어야하므로 청크 된 전송 인코딩이 필요하지 않습니다. 엔터티 본문이있는 경우 Content-Length가 있어야하지만 길이가 명시 적으로 지정되지 않은 경우에도 규칙은 합리적인 동작을 보장합니다.
<hr/>

### 5. General Header Fields

Pragma, Transfer-Encoding 및 Upgrade 헤더를 제외하고 [H4.5]를 참조하십시오.    정의되지 않았습니다 :

      general-header     =     Cache-Control     ; Section 12.8
                         |     Connection        ; Section 12.10
                         |     Date              ; Section 12.18
                         |     Via               ; Section 12.43
<hr/>

### 6. Request

클라이언트에서 서버로 또는 그 반대로의 요청 메시지는 해당 메시지의 첫 번째 라인 내에 자원에 적용되는 방법, 자원의 식별자 및 사용중인 프로토콜 버전을 포함합니다.

       Request      =       Request-Line          ; Section 6.1
                    *(      general-header        ; Section 5
                    |       request-header        ; Section 6.2
                    |       entity-header )       ; Section 8.1
                            CRLF
                            [ message-body ]      ; Section 4.3
<hr/>

#### 6.1 Request Line

      Request-Line = Method SP Request-URI SP RTSP-Version CRLF

      Method         =         "DESCRIBE"              ; Section 10.2
                        |         "ANNOUNCE"              ; Section 10.3
                        |         "GET_PARAMETER"         ; Section 10.8
                        |         "OPTIONS"               ; Section 10.1
                        |         "PAUSE"                 ; Section 10.6
                        |         "PLAY"                  ; Section 10.5
                        |         "RECORD"                ; Section 10.11
                        |         "REDIRECT"              ; Section 10.10
                        |         "SETUP"                 ; Section 10.4
                        |         "SET_PARAMETER"         ; Section 10.9
                        |         "TEARDOWN"              ; Section 10.7
                        |         extension-method

      extension-method = token

      Request-URI = "*" | absolute_URI

      RTSP-Version = "RTSP" "/" 1*DIGIT "." 1*DIGIT
<hr/>

#### 6.2 Request Header Fields

      request-header  =          Accept                   ; Section 12.1
                        |          Accept-Encoding          ; Section 12.2
                        |          Accept-Language          ; Section 12.3
                        |          Authorization            ; Section 12.5
                        |          From                     ; Section 12.20
                        |          If-Modified-Since        ; Section 12.23
                        |          Range                    ; Section 12.29
                        |          Referer                  ; Section 12.30
                        |          User-Agent               ; Section 12.41


HTTP / 1.1 [2]와 달리 RTSP 요청에는 항상 절대 경로가 아닌 절대 URL (구성표, 호스트 및 포트 포함)이 포함됩니다.      

HTTP / 1.1에서는 서버가 절대 URL을 이해해야하지만 클라이언트는 호스트 요청 헤더를 사용해야합니다. 이것은 RTSP에는 적용되지 않는 HTTP / 1.0 서버와의 하위 호환성을 위해 순수하게 필요합니다.    

Request-URI에서 별표 "*"는 요청이 특정 자원이 아니라 서버 자체에 적용되고 사용 된 방법이 자원에 반드시 적용되지 않는 경우에만 허용됨을 의미합니다.

One example would be:

     OPTIONS * RTSP/1.0
<hr/>

### 7. Response

HTTP 버전이 RTSP 버전으로 대체되는 것을 제외하고 [H6]이 적용됩니다.    또한 RTSP는 추가 상태 코드를 정의하고 일부 HTTP 코드를 정의하지 않습니다. 유효한 응답 코드 및 이들이 사용할 수있는 방법은 표 1에 정의되어 있습니다.    요청 메시지를 수신하고 해석 한 후 수신자는 RTSP 응답 메시지로 응답합니다.


     Response    =     Status-Line         ; Section 7.1
                 *(    general-header      ; Section 5
                 |     response-header     ; Section 7.1.2
                 |     entity-header )     ; Section 8.1
                       CRLF
                       [ message-body ]    ; Section 4.3
<hr/>

#### 7.1 Status-Line
응답 메시지의 첫 번째 줄은 상태 버전으로, 프로토콜 버전 뒤에 숫자 상태 코드와 상태 코드와 관련된 텍스트 문구가 있으며 각 요소는 SP 문자로 구분됩니다. 최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다.

      Status-Line =   RTSP-Version SP Status-Code SP Reason-Phrase CRLF
<hr/>

#### 7.1.1 Status Code and Reason Phrase

Status-Code 요소는 요청을 이해하고 만족시키기위한 3 자리 정수 결과 코드입니다. 이 코드는 11 절에 완전히 정의되어 있습니다. 이유 문구는 상태 코드에 대한 간단한 텍스트 설명을 제공하기위한 것입니다. Status-Code는 오토마타에서 사용하기위한 것이며 Reason-Phrase는 사용자를위한 것입니다. 클라이언트는 이유 문구를 조사하거나 표시 할 필요가 없습니다.    
Status-Code의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5 개의 값이 있습니다.

* 1xx: Informational - Request received, continuing process
* 2xx: Success - The action was successfully received, understood,
       and accepted
* 3xx: Redirection - Further action must be taken in order to
       complete the request
* 4xx: Client Error - The request contains bad syntax or cannot be
       fulfilled
* 5xx: Server Error - The server failed to fulfill an apparently
       valid request

RTSP / 1.0에 대해 정의 된 숫자 상태 코드의 개별 값과 해당하는 이유 문구 세트의 예가 아래에 나와 있습니다. 여기에 나열된 이유 문구는 권장 사항입니다. 프로토콜에 영향을 미치지 않으면 서 해당하는 문구로 대체 할 수 있습니다. RTSP는 대부분의 HTTP / 1.1 [2] 상태 코드를 채택하고 새로 정의 된 HTTP 상태 코드와의 충돌을 피하기 위해 x50에서 시작하는 RTSP 특정 상태 코드를 추가합니다.

      Status-Code  =     "100"      ; Continue
                  |     "200"      ; OK
                  |     "201"      ; Created
                  |     "250"      ; Low on Storage Space
                  |     "300"      ; Multiple Choices
                  |     "301"      ; Moved Permanently
                  |     "302"      ; Moved Temporarily
                  |     "303"      ; See Other
                  |     "304"      ; Not Modified
                  |     "305"      ; Use Proxy
                  |     "400"      ; Bad Request
                  |     "401"      ; Unauthorized
                  |     "402"      ; Payment Required
                  |     "403"      ; Forbidden
                  |     "404"      ; Not Found
                  |     "405"      ; Method Not Allowed
                  |     "406"      ; Not Acceptable
                  |     "407"      ; Proxy Authentication Required
                  |     "408"      ; Request Time-out
                  |     "410"      ; Gone
                  |     "411"      ; Length Required
                  |     "412"      ; Precondition Failed
                  |     "413"      ; Request Entity Too Large
                  |     "414"      ; Request-URI Too Large
                  |     "415"      ; Unsupported Media Type
                  |     "451"      ; Parameter Not Understood
                  |     "452"      ; Conference Not Found
                  |     "453"      ; Not Enough Bandwidth
                  |     "454"      ; Session Not Found
                  |     "455"      ; Method Not Valid in This State
                  |     "456"      ; Header Field Not Valid for Resource
                  |     "457"      ; Invalid Range
                  |     "458"      ; Parameter Is Read-Only
                  |     "459"      ; Aggregate operation not allowed
                  |     "460"      ; Only aggregate operation allowed
                  |     "461"      ; Unsupported transport
                  |     "462"      ; Destination unreachable
                  |     "500"      ; Internal Server Error
                  |     "501"      ; Not Implemented
                  |     "502"      ; Bad Gateway
                  |     "503"      ; Service Unavailable
                  |     "504"      ; Gateway Time-out
                  |     "505"      ; RTSP Version not supported
                  |     "551"      ; Option not supported
                  |     extension-code
      extension-code  =     3DIGIT
      Reason-Phrase  =     *<TEXT, excluding CR, LF>

RTSP 상태 코드는 확장 가능합니다. RTSP 응용 프로그램은 등록 된 모든 상태 코드의 의미를 이해해야 할 필요는 없지만 그러한 이해는 분명히 바람직합니다. 그러나 응용 프로그램은 첫 번째 숫자로 표시된 상태 코드의 클래스를 이해해야하며 인식 할 수없는 응답을 캐시해서는 안된다는 점을 제외하고 인식 할 수없는 응답을 해당 클래스의 x00 상태 코드와 동등한 것으로 처리해야합니다. 예를 들어, 클라이언트가 인식 할 수없는 상태 코드 431을 수신하면 요청에 문제가 있다고 가정하고 응답을 400 상태 코드를 수신 한 것처럼 처리 할 수 있습니다. 그러한 경우, 사용자 에이전트는 응답과 함께 리턴 된 엔티티가 사용자에게 제시해야한다. 왜냐하면 해당 엔티티는 비정상적인 상태를 설명하는 사람이 읽을 수있는 정보를 포함 할 가능성이 있기 때문이다.
```
    Code           reason


   100            Continue                         all
   200            OK                               all
   201            Created                          RECORD
   250            Low on Storage Space             RECORD
   300            Multiple Choices                 all
   301            Moved Permanently                all
   302            Moved Temporarily                all
   303            See Other                        all
   305            Use Proxy                        all
   400            Bad Request                      all
   401            Unauthorized                     all
   402            Payment Required                 all
   403            Forbidden                        all
   404            Not Found                        all
   405            Method Not Allowed               all
   406            Not Acceptable                   all
   407            Proxy Authentication Required    all
   408            Request Timeout                  all
   410            Gone                             all
   411            Length Required                  all
   412            Precondition Failed              DESCRIBE, SETUP
   413            Request Entity Too Large         all
   414            Request-URI Too Long             all
   415            Unsupported Media Type           all
   451            Invalid parameter                SETUP
   452            Illegal Conference Identifier    SETUP
   453            Not Enough Bandwidth             SETUP
   454            Session Not Found                all
   455            Method Not Valid In This State   all
   456            Header Field Not Valid           all
   457            Invalid Range                    PLAY
   458            Parameter Is Read-Only           SET_PARAMETER
   459            Aggregate Operation Not Allowed  all
   460            Only Aggregate Operation Allowed all
   461            Unsupported Transport            all
   462            Destination Unreachable          all
   500            Internal Server Error            all
   501            Not Implemented                  all
   502            Bad Gateway                      all
   503            Service Unavailable              all
   504            Gateway Timeout                  all
   505            RTSP Version Not Supported       all
   551            Option not support               all

      Table 1: Status codes and their usage with RTSP methods
```
<hr/>

#### 7.1.2 Response Header Fields

응답 헤더 필드를 사용하면 요청 수신자가 상태 행에 배치 할 수없는 응답에 대한 추가 정보를 전달할 수 있습니다. 이 헤더 필드는 서버 및 Request-URI로 식별 된 자원에 대한 추가 액세스에 대한 정보를 제공합니다.
```
 response-header  =     Location             ; Section 12.25
                    |     Proxy-Authenticate   ; Section 12.26
                    |     Public               ; Section 12.28
                    |     Retry-After          ; Section 12.31
                    |     Server               ; Section 12.36
                    |     Vary                 ; Section 12.42
                    |     WWW-Authenticate     ; Section 12.44
```
응답 헤더 필드 이름은 프로토콜 버전의 변경과 함께 만 안정적으로 확장 될 수 있습니다. 그러나 통신의 모든 당사자가 응답 헤더 필드로 인식하는 경우 새로운 헤더 필드 또는 실험 헤더 필드에 응답 헤더 필드의 의미가 부여 될 수 있습니다 (MAY). 인식 할 수없는 헤더 필드는 엔티티 헤더 필드로 처리됩니다.
<hr/>

### 8. Entity
요청 및 응답 메시지는 요청 방법 또는 응답 상태 코드에 의해 달리 제한되지 않으면 엔티티를 전송할 수 있습니다. 엔터티는 엔터티 헤더 필드와 엔터티 본문으로 구성되지만 일부 응답에는 엔터티 헤더 만 포함됩니다.    이 섹션에서 보낸 사람과받는 사람은 모두 엔터티를받는 사람과받는 사람에 따라 클라이언트 또는 서버를 나타냅니다.
<hr/>

#### 8.1 Entity Header Fields

엔터티 헤더 필드는 엔터티 본문 또는 본문이없는 경우 요청으로 식별 된 리소스에 대한 선택적 메타 정보를 정의합니다.

     entity-header       =    Allow               ; Section 12.4
                         |    Content-Base        ; Section 12.11
                         |    Content-Encoding    ; Section 12.12
                         |    Content-Language    ; Section 12.13
                         |    Content-Length      ; Section 12.14
                         |    Content-Location    ; Section 12.15
                         |    Content-Type        ; Section 12.16
                         |    Expires             ; Section 12.19
                         |    Last-Modified       ; Section 12.24
                         |    extension-header
     extension-header    =    message-header

확장 헤더 메커니즘을 사용하면 프로토콜을 변경하지 않고 추가 엔티티 헤더 필드를 정의 할 수 있지만 이러한 필드는 수신자가 인식 할 수 있다고 가정 할 수 없습니다. 인식 할 수없는 헤더 필드는 수신자가 무시하고 프록시가 전달해야합니다.
<hr/>

#### 8.2 Entity Body

   See [H7.2]
<hr/>

### 9. Connections
RTSP 요청은 여러 가지 방법으로 전송 될 수 있습니다.      
여러 요청-응답 트랜잭션에 사용되는 영구 전송 연결  
   
* 요청 / 응답 트랜잭션 당 하나의 연결;      
* 비 연결 모드.    

전송 연결 유형은 RTSP URI (섹션 3.2)에 의해 정의됩니다. "rtsp"체계의 경우 영구 연결이 가정되고 "rtspu"체계는 연결을 설정하지 않고 RTSP 요청을 전송하도록 요구합니다.    
HTTP와 달리 RTSP를 사용하면 미디어 서버가 미디어 클라이언트에 요청을 보낼 수 있습니다. 그러나 미디어 서버는 클라이언트에 신뢰할 수있는 방법을 제공하지 않으므로 영구 연결에 대해서만 지원됩니다. 또한 미디어 서버에서 클라이언트로의 요청이 방화벽을 통과 할 수있는 유일한 방법입니다.
<hr/>

#### 9.1 Pipelining
영구 연결 또는 비 연결 모드를 지원하는 클라이언트는 요청을 "파이프 라인"할 수 있습니다 (즉, 각 응답을 기다리지 않고 여러 요청을 보낼 수 있음). 서버는 요청을받은 순서대로 응답을 해당 요청에 보내야합니다.
<hr/>

#### 9.2 Reliability and Acknowledgements

멀티 캐스트 그룹으로 전송되지 않으면 수신자가 요청을 승인합니다. 확인 응답이 없으면 발신자는 1 회 왕복 시간 (RTT) 시간 초과 후 동일한 메시지를 다시 보낼 수 있습니다. 왕복 시간은 TCP (RFC 1123) [18]에서와 같이 추정되며 초기 왕복 값은 500ms입니다. 구현은 마지막 RTT 측정을 향후 연결의 초기 값으로 캐시 할 수 있습니다.    

RTSP를 전달하기 위해 신뢰할 수있는 전송 프로토콜을 사용하는 경우 요청을 다시 전송해서는 안됩니다. RTSP 애플리케이션은 대신 신뢰성을 제공하기 위해 기본 전송에 의존해야합니다.      

TCP와 같은 기본 안정적인 전송 및 RTSP 응용 프로그램이 요청을 다시 전송하면 각 패킷 손실로 인해 두 번의 재전송이 발생할 수 있습니다. 전송 스택은 첫 번째 시도가 수신기에 도달하기 전에 애플리케이션 계층 재전송을 전달하지 않기 때문에 수신기는 일반적으로 애플리케이션 계층 재전송을 이용할 수 없다.      

정체로 인해 패킷 손실이 발생하면 다른 계층에서 여러 번의 재전송으로 인해 정체가 악화 될 수 있습니다.

소형 RTT LAN을 통해 RTSP를 사용하는 경우 T / TCP (RFC 1644) [22]에 사용 된 것과 같은 초기 TCP 왕복 추정을 최적화하는 표준 절차가 유리할 수 있습니다.    
타임 스탬프 헤더 (섹션 12.38)는 재전송 모호성 문제를 피하기 위해 사용됩니다 [23, p. 301], Karn 알고리즘의 필요성을 제거합니다.    
각 요청은 CSeq 헤더 (12.17 절)에 시퀀스 번호를 전달하며, 전송 된 각 개별 요청에 대해 1 씩 증가합니다. 승인이 부족하여 요청이 반복되는 경우 요청에는 원래 시퀀스 번호가 있어야합니다 (즉, 시퀀스 번호가 증가하지 않아야 함).    
RTSP를 구현하는 시스템은 반드시 TCP를 통한 RTSP 전송을 지원해야하며 UDP를 지원할 수도 있습니다. RTSP 서버의 기본 포트는 UDP와 TCP 모두에서 554입니다.    
동일한 제어 엔드 포인트로 향하는 다수의 RTSP 패킷은 단일 하위 계층 PDU에 패킹되거나 TCP 스트림으로 캡슐화 될 수있다. RTSP 데이터는 RTP 및 RTCP 패킷과 인터리브 될 수 있습니다. HTTP와 달리 RTSP 메시지는 메시지에 페이로드가 포함될 때마다 Content-Length 헤더를 포함해야합니다. 그렇지 않으면 RTSP 패킷은 마지막 메시지 헤더 바로 다음에 빈 줄로 종료됩니다.
<hr/>

### 10. Method Definitions

메소드 토큰은 Request-URI로 식별 된 자원에서 수행 될 메소드를 나타냅니다. 이 방법은 대소 문자를 구분합니다. 향후 새로운 방법이 정의 될 수 있습니다. 메소드 이름은 $ 문자 (10 진수 24)로 시작할 수 없으며 토큰이어야합니다. 방법은 표 2에 요약되어 있습니다.

      method            direction        object     requirement
      DESCRIBE          C->S             P,S        recommended
      ANNOUNCE          C->S, S->C       P,S        optional
      GET_PARAMETER     C->S, S->C       P,S        optional
      OPTIONS           C->S, S->C       P,S        required
                                                    (S->C: optional)
      PAUSE             C->S             P,S        recommended
      PLAY              C->S             P,S        required
      RECORD            C->S             P,S        optional
      REDIRECT          S->C             P,S        optional
      SETUP             C->S             S          required
      SET_PARAMETER     C->S, S->C       P,S        optional
      TEARDOWN          C->S             P,S        required

      Table 2: Overview of RTSP methods, their direction, and what objects (P: presentation, S: stream) they operate on

표 2 : 참고 사항 : 일시 중지가 권장되지만 라이브 피드와 같이이 방법을 지원하지 않는 모든 기능을 갖춘 서버를 구축 할 수있는 것은 아닙니다. 서버가 특정 방법을 지원하지 않으면 반드시 "501 Not Implemented"를 반환해야하며 클라이언트는이 서버에 대해이 방법을 다시 시도하지 않아야합니다.
<hr/>

#### 10.1. OPTIONS

동작은 [H9.2]에 설명 된 것과 동일합니다. 예를 들어 클라이언트가 비표준 요청을 시도하려는 경우 언제라도 OPTIONS 요청이 발행 될 수 있습니다. 서버 상태에는 영향을 미치지 않습니다.

     C->S:  OPTIONS * RTSP/1.0
            CSeq: 1
            Require: implicit-play
            Proxy-Require: gzipped-messages


     S->C:  RTSP/1.0 200 OK
            CSeq: 1
            Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE

이것들은 필연적으로 허구의 특징입니다 (이 섹션에서 우리가 강력한 예를 가질 수 있도록 실제로 유용한 기능을 의도적으로 간과하지 않기를 바랍니다).
<hr/>

#### 10.2. DESCRIBE
표현에 대한 설명을 탐색하거나 서버의 요청 URL로 식별되는 미디어 객체
클라이언트가 이해하는 포맷을 명확히 하기 위해 Accept header를 이용한다. 
이 요청과 응답 쌍은 RTSP의 미디어 초기 단계를 구성한다.

미디어 클라이언트가 DESCRIBE 이외의 소스에서 프리젠 테이션 설명을 가져오고 해당 설명에 완전한 미디어 초기화 매개 변수 세트가 포함 된 경우 클라이언트는 해당 매개 변수를 사용해야하며 RTSP를 통해 동일한 미디어에 대한 설명을 요청하지 않아야합니다. 
DESCRIBE 메소드는 서버에서 요청 URL로 식별 된 프리젠 테이션 또는 매체 오브젝트의 설명을 검색합니다. Accept 헤더를 사용하여 클라이언트가 이해하는 설명 형식을 지정할 수 있습니다. 서버는 요청 된 자원에 대한 설명으로 응답합니다. DESCRIBE 응답-응답 쌍은 RTSP의 미디어 초기화 단계를 구성합니다.
```
   Example:


     C->S: DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/1.0
           CSeq: 312
           Accept: application/sdp, application/rtsl, application/mheg


     S->C: RTSP/1.0 200 OK
           CSeq: 312
           Date: 23 Jan 1997 15:35:06 GMT
           Content-Type: application/sdp
           Content-Length: 376


           v=0
           o=mhandley 2890844526 2890842807 IN IP4 126.16.64.4
           s=SDP Seminar
           i=A Seminar on the session description protocol
           u=http://www.cs.ucl.ac.uk/staff/M.Handley/sdp.03.ps
           e=mjh@isi.edu (Mark Handley)
           c=IN IP4 224.2.17.12/127
           t=2873397496 2873404696
           a=recvonly
           m=audio 3456 RTP/AVP 0
           m=video 2232 RTP/AVP 31
           m=whiteboard 32416 UDP WB
           a=orient:portrait
```

DESCRIBE 응답에는 설명하는 리소스에 대한 모든 미디어 초기화 정보가 포함되어야합니다. 미디어 클라이언트가 DESCRIBE 이외의 소스에서 프리젠 테이션 설명을 가져오고 해당 설명에 완전한 미디어 초기화 매개 변수 세트가 포함 된 경우 클라이언트는 해당 매개 변수를 사용해야하며 RTSP를 통해 동일한 미디어에 대한 설명을 요청하지 않아야합니다.

또한 서버는 미디어 간접 수단으로 DESCRIBE 응답을 사용하지 않아야합니다.      
클라이언트가 DESCRIBE를 통해 미디어 초기화 정보를 요청하는시기와 그렇지 않은시기를 명확하게 알 수 있도록 명확한 기본 규칙을 수립해야합니다. 설명하는 스트림 세트에 대한 모든 미디어 초기화를 포함하도록 DESCRIBE 응답을 강제하고 미디어 간접 처리에 DESCRIBE 사용을 권장하지 않으면 다른 접근 방식으로 인해 발생할 수있는 루핑 문제를 피할 수 있습니다.      
미디어 초기화는 모든 RTSP 기반 시스템의 요구 사항이지만 RTSP 사양에서는이를 DESCRIBE 방법을 통해 수행해야한다고 명시하지 않습니다. RTSP 클라이언트가 초기화 정보를 수신 할 수있는 세 가지 방법이 있습니다.      

* RTSP의 DESCRIBE 방법을 통해;      
* 다른 프로토콜 (HTTP, 이메일 첨부 파일 등)을 통해;      
* 커맨드 라인 또는 표준 입력을 통해      

실질적인 상호 운용성을 위해 최소한의 서버는 DESCRIBE 방법을 지원하고, 최소한의 클라이언트는 표준 입력, 명령 줄 및 미디어 입력에서 미디어 초기화 파일을받는 "도우미 응용 프로그램"으로 작동하는 기능을 지원하는 것이 좋습니다. 클라이언트의 운영 환경에 적합한 다른 수단.
<hr/>

#### 10.3.ANNOUNCE
ANNOUNCE 는 두가지 목적을 가진다.
1. 클라이언트에서 서버로 보낼 때, 요청 URL에 의해 식별된 미디어 Object와 Presentation 에 대한 정보를 게시한다. 서버에서 클라이언트로 보낼 때, 실시간 세션 정보를 업데이트 한다.
2. 만약 새로운 미디어 스트림이 presentation 에 추가 되었을 때, 추가적인 컴포넌트를 첨부하지 않고, 전체 presentation description은 다시 보내진다. So, 그 컴포넌트는 삭제된다.
```
     C->S: ANNOUNCE rtsp://server.example.com/fizzle/foo RTSP/1.0
           CSeq: 312
           Date: 23 Jan 1997 15:35:06 GMT
           Session: 47112344
           Content-Type: application/sdp
           Content-Length: 332


           v=0
           o=mhandley 2890844526 2890845468 IN IP4 126.16.64.4
           s=SDP Seminar
           i=A Seminar on the session description protocol
           u=http://www.cs.ucl.ac.uk/staff/M.Handley/sdp.03.ps
           e=mjh@isi.edu (Mark Handley)
           c=IN IP4 224.2.17.12/127
           t=2873397496 2873404696
           a=recvonly
           m=audio 3456 RTP/AVP 0
           m=video 2232 RTP/AVP 31


     S->C: RTSP/1.0 200 OK
           CSeq: 312
```
<hr/>


#### 10.4. SETUP
URI에 대한 SETUP 요청은 스트리밍 미디어에 사용될 전송 메커니즘을 지정합니다. 클라이언트는 서버가 허용 할 수있는 전송 매개 변수를 변경하기 위해 이미 재생중인 스트림에 대해 SETUP 요청을 발행 할 수 있습니다. 이를 허용하지 않으면 "455 상태가 유효하지 않음"오류로 응답해야합니다. 중재 방화벽의 이점을 위해 클라이언트는 전송 매개 변수를 표시해야합니다 (예 : 서버가 고정 멀티 캐스트 주소를 광고하는 경우)

SETUP에는 모든 전송 초기화 정보가 포함되어 있으므로 방화벽 및 기타 중간 네트워크 장치 (이 정보가 필요한)에는 미디어 초기화 용으로 예약 된 DESCRIBE 응답을 구문 분석하는보다 어려운 작업이 필요하지 않습니다.

   전송 헤더는 클라이언트가 데이터 전송에 허용 할 수있는 전송 매개 변수를 지정합니다. 응답에는 서버가 선택한 전송 매개 변수가 포함됩니다.
```
    C->S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/1.0
          CSeq: 302
          Transport: RTP/AVP;unicast;client_port=4588-4589




    S->C: RTSP/1.0 200 OK
          CSeq: 302
          Date: 23 Jan 1997 15:35:06 GMT
          Session: 47112344
          Transport: RTP/AVP;unicast;
            client_port=4588-4589;server_port=6256-6257
```



서버는 SETUP 요청에 대한 응답으로 세션 식별자를 생성했습니다. 서버에 대한 설정 요청에 세션 식별자가 포함 된 경우, 서버는이 설정 요청을 기존 세션에 묶거나 "459 집계 작업이 허용되지 않음"오류를 반환해야합니다 (11.3.10 참조).

PLAY 방법은 서버가 SETUP에 지정된 메커니즘을 통해 데이터 전송을 시작하도록 지시합니다. 미해결 SETUP 요청이 성공적으로 승인 될 때까지 클라이언트는 PLAY 요청을 발행해서는 안됩니다 (MUST NOT).    PLAY 요청은 정상 재생 시간을 지정된 범위의 시작 부분에 배치하고 범위의 끝에 도달 할 때까지 스트림 데이터를 전달합니다. PLAY 요청은 파이프 라인 (큐잉) 될 수 있습니다. 서버는 PLAY 요청이 순서대로 실행되도록 대기해야합니다. 즉, PLAY    이전 PLAY 요청이 여전히 활성화되어있는 동안 도착하는 요청은 첫 번째가 완료 될 때까지 지연됩니다.      정확한 편집이 가능합니다.    예를 들어, 아래 예에서 두 PLAY 요청이 얼마나 근접한 간격에 도달했는지에 관계없이 서버는 먼저 10 초에서 15 초를 재생 한 다음 바로 20 초에서 25 초, 마지막으로 30 초를 끝까지 재생합니다

     C->S: PLAY rtsp://audio.example.com/audio RTSP/1.0
           CSeq: 835
           Session: 12345678
           Range: npt=10-15


     C->S: PLAY rtsp://audio.example.com/audio RTSP/1.0
           CSeq: 836
           Session: 12345678
           Range: npt=20-25


     C->S: PLAY rtsp://audio.example.com/audio RTSP/1.0
           CSeq: 837
           Session: 12345678
           Range: npt=30-


추가 예는 PAUSE 요청 설명을 참조하십시오.    Range 헤더가없는 PLAY 요청은 합법적입니다. 스트림이 일시 중지되지 않은 경우 처음부터 스트림 재생을 시작합니다. PAUSE를 통해 스트림이 일시 중지 된 경우 일시 중지 지점에서 스트림 배달이 다시 시작됩니다. 스트림이 재생중인 경우 이러한 PLAY 요청은 추가 조치를 발생시키지 않으며 클라이언트가 서버 작동을 테스트하는 데 사용할 수 있습니다.


Range 헤더에는 시간 매개 변수가 포함될 수도 있습니다. 이 매개 변수는 재생이 시작되는 시간을 UTC로 지정합니다. 지정된 시간 이후에 메시지가 수신되면 즉시 재생이 시작됩니다. 시간 파라미터는 상이한 소스로부터 획득 된 스트림의 동기화를 돕기 위해 사용될 수있다.    주문형 스트림의 경우 서버는 재생할 실제 범위로 응답합니다. 미디어 소스에 대해 요청 된 범위를 유효한 프레임 경계로 정렬해야하는 경우 요청 된 범위와 다를 수 있습니다. 요청에 범위를 지정하지 않으면 현재 위치가 회신에 반환됩니다. 응답의 범위 단위는 요청의 단위와 동일합니다.    원하는 범위를 재생 한 후에는 일시 정지 요청이 발행 된 것처럼 프리젠 테이션이 자동으로 일시 정지됩니다.    다음 예제는 SMPTE 타임 코드 0:10:20에서 시작하여 클립 끝까지 전체 프레젠테이션을 재생합니다. 재생은 1997 년 1 월 23 일 15:36에 시작됩니다.
```
     C->S: PLAY rtsp://audio.example.com/twister.en RTSP/1.0
           CSeq: 833
           Session: 12345678
           Range: smpte=0:10:20-;time=19970123T153600Z


     S->C: RTSP/1.0 200 OK
           CSeq: 833
           Date: 23 Jan 1997 15:35:06 GMT
           Range: smpte=0:10:22-;time=19970123T153600Z
```
라이브 프리젠 테이션의 레코딩을 재생하려면 시계 단위를 사용하는 것이 바람직 할 수 있습니다
```
     C->S: PLAY rtsp://audio.example.com/meeting.en RTSP/1.0
           CSeq: 835
           Session: 12345678
           Range: clock=19961108T142300Z-19961108T143520Z


     S->C: RTSP/1.0 200 OK
           CSeq: 835
           Date: 23 Jan 1997 15:35:06 GMT
```
재생 만 지원하는 미디어 서버는 반드시 npt 형식을 지원해야하며 clock 및 smpte 형식을 지원해야합니다.
<hr/>

#### 10.5. PAUSE
PAUSE 요청으로 인해 스트림 전송이 일시적으로 중단 (중지)됩니다. 요청 URL이 스트림 이름을 지정하면 해당 스트림의 재생 및 기록 만 중지됩니다. 예를 들어 오디오의 경우 음소거와 같습니다. 요청 URL이 프리젠 테이션 또는 스트림 그룹의 이름을 지정하면 프리젠 테이션 또는 그룹 내에서 현재 활성화 된 모든 스트림의 전달이 중지됩니다. 재생 또는 녹음을 재개 한 후에는 트랙의 동기화를 유지해야합니다. 모든 서버 리소스는 유지되지만 SETUP 메시지에서 Session 헤더의 timeout 매개 변수로 지정된 기간 동안 서버가 세션을 닫고 사용 가능한 리소스를 일시 중지 한 경우도 있습니다
```
     C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/1.0
           CSeq: 834
           Session: 12345678


     S->C: RTSP/1.0 200 OK
           CSeq: 834
           Date: 23 Jan 1997 15:35:06 GMT
```
PAUSE 요청은 스트림 또는 프리젠 테이션이 중지 될시기를 지정하는 Range 헤더를 포함 할 수 있습니다. 이 지점을 "일시 정지 지점"이라고합니다. 헤더는 시간 범위가 아닌 정확히 하나의 값을 포함해야합니다. 스트림의 일반 재생 시간이 일시 정지 지점으로 설정되어 있습니다. 일시 중지 요청은 서버가 현재 보류중인 PLAY 요청에 지정된 시점을 처음 만날 때 적용됩니다. Range 헤더가 현재 보류중인 PLAY 요청 이외의 시간을 지정하면 "457 Invalid Range"오류가 반환됩니다. 미디어 장치 (예 : 오디오 또는 비디오 프레임)가 정확하게 일시 정지 지점에서 프리젠 테이션을 시작하면 재생되거나 기록되지 않습니다. Range 헤더가 없으면 메시지 수신 즉시 스트림 전송이 중단되고 일시 정지 지점은 현재 일반 재생 시간으로 설정됩니다.    

PAUSE 요청은 대기중인 모든 PLAY 요청을 삭제합니다. 그러나 미디어 스트림의 일시 정지 지점을 유지해야합니다. Range 헤더가없는 후속 PLAY 요청은 일시 중지 지점에서 다시 시작됩니다.    예를 들어, 서버에 10-15 범위, 20-29 범위 보류 중 재생 요청이 있고 NPT 21에 대한 일시 중지 요청이 수신되면 두 번째 범위 재생이 시작되고 NPT 21에 중지됩니다. 일시 중지 요청이 NPT 12에 대한 경우 서버가 첫 번째 재생 요청을 제공하는 NPT 13에서 재생 중이면 서버가 즉시 중지됩니다. 일시 정지 요청이 NPT 16에 대한 것이면, 서버는 제 1 재생 요청을 완료 한 후 정지하고 제 2 재생 요청을 폐기한다.

다른 예로서, 서버가 재생 범위 10 내지 15,이어서 13 내지 20 (즉, 겹치는 범위)에 대한 요청을 수신 한 경우, 서버는 첫 번째 범위를 재생하는 동안 NPT = 14에 대한 PAUSE 요청이 적용되고, 두 번째는 서버가 두 번째 겹치는 범위 재생을 시작하기 전에 PAUSE 요청이 도착한다고 가정하면 PLAY 요청이 효과적으로 무시됩니다. PAUSE 요청이 도착한 시점에 관계없이 NPT를 14로 설정합니다.    서버가 Range 헤더에 지정된 시간을 초과하여 이미 데이터를 전송 한 경우 클라이언트가 해당 시점 이후에 데이터를 삭제 한 것으로 간주되므로 해당 시점에서 PLAY가 계속 재개됩니다. 이를 통해 간격없이 지속적인 일시 정지 / 재생 사이클이 보장됩니다.
<hr/>

#### 10.6. TEARDOWN
TEARDOWN 요청은 주어진 URI에 대한 스트림 전달을 중지하고 연관된 URI를 해제합니다. URI가이 프리젠 테이션의 프리젠 테이션 URI 인 경우 세션과 연관된 RTSP 세션 ID는 더 이상 유효하지 않습니다. 모든 전송 매개 변수가 세션 설명에 의해 정의되지 않은 경우 세션을 다시 재생하려면 SETUP 요청을 발행해야합니다.
```
     C->S: TEARDOWN rtsp://example.com/fizzle/foo RTSP/1.0
           CSeq: 892
           Session: 12345678
     S->C: RTSP/1.0 200 OK
           CSeq: 892
```
<hr/>

#### 10.7. GET_PARAMETER
GET_PARAMETER 요청은 매개 변수의 값을 검색합니다.    URI에 지정된 프리젠 테이션 또는 스트림. 응답 및 응답의 내용은 구현에 맡겨져 있습니다. 엔티티 본문이없는 GET_PARAMETER를 사용하여 클라이언트 또는 서버 라이브 니스 ( "ping")를 테스트 할 수 있습니다.
```
     S->C: GET_PARAMETER rtsp://example.com/fizzle/foo RTSP/1.0
           CSeq: 431
           Content-Type: text/parameters
           Session: 12345678
           Content-Length: 15


           packets_received
           jitter

     C->S: RTSP/1.0 200 OK
           CSeq: 431
           Content-Length: 46
           Content-Type: text/parameters
           packets_received: 10
           jitter: 0.3838
```
"text / parameters"섹션은 매개 변수의 예제 유형일뿐입니다. 이 방법은 추가 실험 후에 응답 내용 및 응답 내용이 정의 될 것이라는 의도로 의도적으로 느슨하게 정의된다
<hr/>

#### 10.8. SET_PARAMETER
이 메소드는 URI로 지정된 프리젠 테이션 또는 스트림에 대한 매개 변수 값 설정을 요청합니다.      
요청에는 클라이언트가 특정 요청이 실패한 이유를 결정할 수 있도록 단일 매개 변수 만 포함해야합니다. 요청에 여러 매개 변수가 포함되어 있으면 모든 매개 변수를 성공적으로 설정할 수있는 경우에만 서버가 요청에 따라 작동해야합니다. 서버는 매개 변수가 동일한 값으로 반복적으로 설정되도록 허용해야하지만 매개 변수 값 변경을 허용하지 않을 수 있습니다.   

 참고 : 미디어 스트림의 전송 매개 변수는 SETUP 명령으로 만 설정해야합니다.      
전송 매개 변수 설정을 SETUP으로 제한하면 방화벽의 이점이 있습니다.
      매개 변수는보다 의미있는 오류 표시가있을 수 있도록 세분화 된 방식으로 분할됩니다. 그러나 원자 설정이 필요한 경우 여러 매개 변수를 설정하는 것이 좋습니다. 클라이언트가 카메라가 동시에 직각으로 기울어지지 않는 한 카메라가 움직이지 않도록하는 위치를 제어한다고 상상해보십시오.
```
     C->S: SET_PARAMETER rtsp://example.com/fizzle/foo RTSP/1.0
           CSeq: 421
           Content-length: 20
           Content-type: text/parameters


           barparam: barstuff


     S->C: RTSP/1.0 451 Invalid Parameter
           CSeq: 421
           Content-length: 10
           Content-type: text/parameters


           barparam
```

"text / parameters"섹션은 매개 변수의 예제 유형일뿐입니다. 이 방법은 추가 실험 후에 응답 내용 및 응답 내용이 정의 될 것이라는 의도로 의도적으로 느슨하게 정의된다
<hr/>

#### 10.9. REDIRECT

리디렉션 요청은 클라이언트에게 다른 서버 위치에 연결해야 함을 알려줍니다. 여기에는 클라이언트가 해당 URL에 대한 요청을 발행해야 함을 나타내는 필수 헤더 Location이 포함되어 있습니다. 리디렉션이 적용되는시기를 나타내는 Range 매개 변수가 포함될 수 있습니다. 클라이언트가이 URI에 대한 미디어를 계속 보내거나 받으려면 클라이언트는 현재 세션에 대한 TEARDOWN 요청과 지정된 호스트에서 새 세션에 대한 SETUP을 발행해야합니다.
```
     S->C: REDIRECT rtsp://example.com/fizzle/foo RTSP/1.0
           CSeq: 732
           Location: rtsp://bigserver.com:8001
           Range: clock=19960213T143205Z-
```
<hr/>

#### 10.10. RECORD
이 방법은 프리젠 테이션 설명에 따라 다양한 미디어 데이터의 기록을 시작한다. 타임 스탬프는 시작 및 종료 시간 (UTC)을 반영합니다. 시간 범위가 제공되지 않으면 프리젠 테이션 설명에 제공된 시작 또는 종료 시간을 사용하십시오. 세션이 이미 시작된 경우 즉시 기록을 시작하십시오.    서버는 기록 된 데이터를 request-URI 또는 다른 URI에 저장할지 여부를 결정합니다. 서버가 request-URI를 사용하지 않는 경우 응답은 201 (생성)이어야하고 요청 상태를 설명하고 새 자원과 Location 헤더를 나타내는 엔티티를 포함해야합니다.    라이브 프리젠 테이션 녹화를 지원하는 미디어 서버는 반드시 시계 범위 형식을 지원해야합니다. smpte 형식은 의미가 없습니다.

이 예에서 미디어 서버는 이전에 표시된 회의에 초대되었습니다
```
     C->S: RECORD rtsp://example.com/meeting/audio.en RTSP/1.0
           CSeq: 954
           Session: 12345678
           Conference: 128.16.64.19/32492374
```
<hr/>

#### 10.11. Embedded (Interleaved) Binary Data
특정 방화벽 설계 및 기타 환경에서는 서버가 RTSP 방법을 인터리브하고 데이터를 스트리밍해야 할 수 있습니다. 이 인터리빙은 일반적으로 클라이언트와 서버 작동을 복잡하게하고 추가 오버 헤드를 유발하므로 필요하지 않으면 피해야합니다. 인터리브 된 이진 데이터는 RTSP가 TCP를 통해 전달되는 경우에만 사용해야합니다.    RTP 패킷과 같은 스트림 데이터는 ASCII 달러 부호 (16 진수 24), 1 바이트 채널 식별자, 캡슐화 된 2 진 데이터 길이를 2 바이트 정수로 네트워크 바이트 순서로 캡슐화합니다. 스트림 데이터는 CRLF없이 즉시 상위 계층 프로토콜 헤더를 포함하여 따릅니다. 각 $ 블록에는 정확히 하나의 상위 계층 프로토콜 데이터 단위 (예 : 하나의 RTP 패킷)가 포함됩니다.

채널 식별자는 전송 헤더에서 인터리브 매개 변수 (12.39 절)와 함께 정의됩니다.    전송 선택이 RTP 인 경우 RTCP 메시지는 TCP 연결을 통해 서버에 의해 인터리브됩니다. 기본적으로 RTCP 패킷은 RTP 채널보다 높은 첫 번째 사용 가능한 채널로 전송됩니다. 클라이언트는 다른 채널에서 RTCP 패킷을 명시 적으로 요청할 수 있습니다. 이것은 트랜스 포트 헤더의 인터리브 된 파라미터에서 두 개의 채널을 지정함으로써 이루어진다 (12.39 절).      RTCP는 이러한 방식으로 두 개 이상의 스트림이 인터리브 될 때 동기화에 필요합니다. 또한 네트워크 구성에 필요한 경우 TCP 제어 연결을 통해 RTP / RTCP 패킷을 터널링하고 가능한 경우 UDP로 전송하는 편리한 방법을 제공합니다
```
     C->S: SETUP rtsp://foo.com/bar.file RTSP/1.0
           CSeq: 2
           Transport: RTP/AVP/TCP;interleaved=0-1


     S->C: RTSP/1.0 200 OK
           CSeq: 2
           Date: 05 Jun 1997 18:57:18 GMT
           Transport: RTP/AVP/TCP;interleaved=0-1
           Session: 12345678


     C->S: PLAY rtsp://foo.com/bar.file RTSP/1.0
           CSeq: 3
           Session: 12345678


     S->C: RTSP/1.0 200 OK
           CSeq: 3
           Session: 12345678
           Date: 05 Jun 1997 18:59:15 GMT
           RTP-Info: url=rtsp://foo.com/bar.file;
             seq=232433;rtptime=972948234


     S->C: $\000{2 byte length}{"length" bytes data, w/RTP header}
     S->C: $\000{2 byte length}{"length" bytes data, w/RTP header}
     S->C: $\001{2 byte length}{"length" bytes  RTCP packet}
```
<hr/>


### 11.Status Code Definitions
해당되는 경우 HTTP 상태 [H10] 코드가 재사용됩니다. 동일한 의미의 상태 코드는 여기에서 반복되지 않습니다. 어떤 요청에 의해 어떤 상태 코드가 리턴 될 수 있는지에 대한 목록은 표 1을 참조하십시오
<hr/>

#### 11.1 Success 2xx
#### 11.1.1 250 Low on Storage Space
서버는 저장 공간이 부족하여 완전히 이행하지 못할 수있는 RECORD 요청을 수신 한 후이 경고를 리턴합니다. 가능한 경우 서버는 Range 헤더를 사용하여 여전히 기록 할 수있는 기간을 표시해야합니다. 서버의 다른 프로세스가 동시에 스토리지 공간을 소비 할 수 있으므로 클라이언트는이를 추정치로만 사용해야합니다.
<hr/>

#### 11.2 Redirection 3xx
RTSP 내에서 리디렉션은로드 밸런싱 또는 스트림 요청을 클라이언트와 토폴로지 적으로 가까운 서버로 리디렉션하는 데 사용될 수 있습니다. 위상 근접성을 결정하는 메커니즘은이 사양의 범위를 벗어납니다.
<hr/>

#### 11.3 Client Error 4xx
#### 11.3.1 405 Method Not Allowed
요청에 지정된 메소드는 요청 URI로 식별 된 자원에 허용되지 않습니다. 응답에는 요청 된 자원에 대한 유효한 메소드 목록이 포함 된 Allow 헤더가 포함되어야합니다.    이 상태 코드는 요청이 SETUP 동안 표시되지 않은 방법을 사용하려고 시도하는 경우에도 사용됩니다 (예 : 전송 헤더의 모드 매개 변수 만 PLAY를 지정하더라도 RECORD 요청이 발행 된 경우)
<hr/>

#### 11.3.2 451 Parameter Not Understood

요청의 수신자는 요청에 포함 된 하나 이상의 매개 변수를 지원하지 않습니다.


#### 11.3.3 452 Conference Not Found
회의 헤더 필드로 표시된 회의는 미디어 서버에서 알 수 없습니다.



#### 11.3.4 453 Not Enough Bandwidth
대역폭이 충분하지 않아 요청이 거부되었습니다. 예를 들어 리소스 예약 실패의 결과 일 수 있습니다.


#### 11.3.5 454 Session Not Found
세션 헤더의 RTSP 세션 식별자가 없거나 유효하지 않거나 시간이 초과되었습니다


#### 11.3.6 455 Method Not Valid in This State
클라이언트 또는 서버가이 요청을 현재 상태로 처리 할 수 없습니다. 응답에는 오류 복구를 쉽게하기 위해 Allow 헤더가 포함되어야합니다.


#### 11.3.7 456 Header Field Not Valid for Resource
서버가 필요한 요청 헤더에서 작동 할 수 없습니다. 예를 들어, PLAY에 Range 헤더 필드가 포함되어 있지만 스트림에서 검색을 허용하지 않는 경우

#### 11.3.8 457 Invalid Range
주어진 범위 값이 범위를 벗어났습니다 (예 : 프리젠 테이션 끝을 초과 함).

#### 11.3.9 458 Parameter Is Read-Only
SET_PARAMETER에 의해 설정 될 매개 변수는 읽을 수 있지만 수정할 수는 없습니다.


#### 11.3.10 459 Aggregate Operation Not Allowed
요청 된 메소드는 집계 (프레젠테이션) URL이므로 해당 URL에 적용되지 않을 수 있습니다. 이 방법은 스트림 URL에 적용될 수 있습니다.


#### 11.3.11 460 Only Aggregate Operation Allowed
요청 된 메소드는 집계 (프레젠테이션) URL이 아니므로 해당 URL에 적용되지 않을 수 있습니다. 이 방법은 프리젠 테이션 URL에 적용될 수있다.

  
#### 11.3.12 461 Unsupported Transport
전송 필드에 지원되는 전송 스펙이 없습니다.


#### 11.3.13 462 Destination Unreachable
클라이언트 주소에 도달 할 수 없어 데이터 전송 채널을 설정할 수 없습니다. 이 오류는 클라이언트가 전송 필드에 유효하지 않은 대상 매개 변수를 배치하려고 한 결과 일 가능성이 큽니다.

   
#### 11.3.14 551 Option not supported
요구 사항 또는 프록시 요구 사항 필드에 제공된 옵션이 지원되지 않았습니다. 지원되지 않는 옵션을 나타내는 지원되지 않는 헤더가 반환되어야합니다.
<hr/>

### 12.Header Field Definitions
여기에 나열되지 않은 HTTP / 1.1 [2] 또는 기타 비표준 헤더 필드에는 현재 잘 정의 된 의미가 없으므로 수신자가 무시해야합니다.    표 3에는 RTSP에서 사용되는 헤더 필드가 요약되어 있습니다. "g"유형은 요청과 응답 모두에서 발견 될 일반 요청 헤더를 지정하고 "R"유형은 요청 헤더를 지정하고 "r"유형은 응답 헤더를 지정하고 "e"유형은 엔티티 헤더 필드를 지정합니다. "요청"으로 표시된 필드 "support"로 표시된 열에서 수신자는 특정 방법에 대해 수신자가 구현해야하며 "opt"로 표시된 필드는 반드시 있어야합니다. 선택 사항입니다. "요청"으로 표시된 모든 필드는 아닙니다. 이 유형의 모든 요청에 전송됩니다. "요구 사항" 즉, 클라이언트 (응답 헤더의 경우)와 서버 (요청 헤더의 경우) 만 필드를 구현해야합니다. 마지막 열에는이 헤더 필드가 의미있는 방법이 나열되어 있습니다. "엔티티"라는 명칭은 메시지 본문을 반환하는 모든 메서드를 나타냅니다. 이 사양에서 DESCRIBE와 GET_PARAMETER는이 클래스에 속합니다.
```
    Header               type   support   methods
   Accept               R      opt.      entity
   Accept-Encoding      R      opt.      entity
   Accept-Language      R      opt.      all
   Allow                r      opt.      all
   Authorization        R      opt.      all
   Bandwidth            R      opt.      all
   Blocksize            R      opt.      all but OPTIONS, TEARDOWN
   Cache-Control        g      opt.      SETUP
   Conference           R      opt.      SETUP
   Connection           g      req.      all
   Content-Base         e      opt.      entity
   Content-Encoding     e      req.      SET_PARAMETER
   Content-Encoding     e      req.      DESCRIBE, ANNOUNCE
   Content-Language     e      req.      DESCRIBE, ANNOUNCE
   Content-Length       e      req.      SET_PARAMETER, ANNOUNCE
   Content-Length       e      req.      entity
   Content-Location     e      opt.      entity
   Content-Type         e      req.      SET_PARAMETER, ANNOUNCE
   Content-Type         r      req.      entity
   CSeq                 g      req.      all
   Date                 g      opt.      all
   Expires              e      opt.      DESCRIBE, ANNOUNCE
   From                 R      opt.      all
   If-Modified-Since    R      opt.      DESCRIBE, SETUP
   Last-Modified        e      opt.      entity
   Proxy-Authenticate
   Proxy-Require        R      req.      all
   Public               r      opt.      all
   Range                R      opt.      PLAY, PAUSE, RECORD
   Range                r      opt.      PLAY, PAUSE, RECORD
   Referer              R      opt.      all
   Require              R      req.      all
   Retry-After          r      opt.      all
   RTP-Info             r      req.      PLAY
   Scale                Rr     opt.      PLAY, RECORD
   Session              Rr     req.      all but SETUP, OPTIONS
   Server               r      opt.      all
   Speed                Rr     opt.      PLAY
   Transport            Rr     req.      SETUP
   Unsupported          r      req.      all
   User-Agent           R      opt.      all
   Via                  g      opt.      all
   WWW-Authenticate     r      opt.      all
```
<hr/>

#### 12.1 Accept
요청 헤더 승인 필드를 사용하여 응답에 적합한 특정 프리젠 테이션 설명 컨텐츠 유형을 지정할 수 있습니다.      프리젠 테이션 설명에 대한 "level"매개 변수는 여기가 아니라 MIME 유형 등록의 일부로 올바르게 정의됩니다.    구문은 [H14.1]을 참조하십시오.

Example of use:
     
     Accept: application/rtsl, application/sdp;level=2
<hr/>

#### 12.2 Accept-Encoding

     See [H14.3]

#### 12.3 Accept-Language

[H14.4]를 참조하십시오. 지정된 언어는 미디어 내용이 아닌 프레젠테이션 설명 및 이유 문구에 적용됩니다.

#### 12.4 Allow
응답 헤더 허용 필드에는 request-URI가 식별 한 자원이 지원하는 메소드가 나열됩니다. 이 필드의 목적은 수신자에게 자원과 관련된 유효한 메소드를 엄격하게 알리는 것입니다. 헤더 허용 필드는 405 (허용되지 않는 방법) 응답에 있어야합니다.
   
   Example of use:
   
     Allow: SETUP, PLAY, RECORD, SET_PARAMETER

#### 12.5 Authorization

     See [H14.8]
<hr/>

#### 12.6 Bandwidth

대역폭 요청 헤더 필드는 클라이언트가 사용할 수있는 예상 대역폭을 양의 정수로 표시하고 초당 비트 수로 측정합니다. RTSP 세션 중에 클라이언트가 사용할 수있는 대역폭은 예를 들어 모뎀 재교육으로 인해 변경 될 수 있습니다.

      Bandwidth = "Bandwidth" ":" 1*DIGIT
      Example:
            Bandwidth: 4000
<hr/>

#### 12.7 Blocksize
이 요청 헤더 필드는 서버에서 특정 미디어 패킷 크기를 요청하는 클라이언트에서 미디어 서버로 전송됩니다. 이 패킷 크기에는 IP, UDP 또는 RTP와 같은 하위 계층 헤더가 포함되지 않습니다. 서버는 요청 된 것보다 작은 블록 크기를 자유롭게 사용할 수 있습니다. 서버는이 패킷 크기를 최소 미디어 특정 블록 크기의 가장 가까운 배수로 자르거나 필요할 경우 미디어 특정 크기로 덮어 쓸 수 있습니다. 블록 크기는 반드시 8 진수로 측정 된 양의 10 진수 여야합니다. 서버는 값이 구문 상 유효하지 않은 경우에만 오류 (416)를 리턴합니다.
<hr/>


#### 12.8 Cache-Control
Cache-Control 일반 헤더 필드는 요청 / 응답 체인을 따라 모든 캐싱 메커니즘이 준수해야하는 지시문을 지정하는 데 사용됩니다.    지시문은 요청 / 응답 체인을 따라 모든 수신자에게 적용될 수 있으므로 캐시 지시문은 해당 애플리케이션에 대한 중요성에 관계없이 프록시 또는 게이트웨이 애플리케이션에 의해 전달되어야합니다. 특정 캐시에 대해 캐시 지시문을 지정할 수 없습니다.    Cache-Control은 SETUP 요청 및 해당 응답에서만 지정해야합니다. 참고 : Cache-Control은 HTTP에 대한 응답 캐싱이 아니라 SETUP 요청에 의해 식별 된 스트림이 아닙니다. RTSP 요청에 대한 응답은 DESCRIBE에 대한 응답을 제외하고 캐시 할 수 없습니다.

```
   Cache-Control            =   "Cache-Control" ":" 1#cache-directive
   cache-directive          =   cache-request-directive
                            |   cache-response-directive
   cache-request-directive  =   "no-cache"
                            |   "max-stale"
                            |   "min-fresh"
                            |   "only-if-cached"
                            |   cache-extension
   cache-response-directive =   "public"
                            |   "private"
                            |   "no-cache"
                            |   "no-transform"
                            |   "must-revalidate”
                            |   "proxy-revalidate"
                            |   "max-age" "=" delta-seconds
                            |   cache-extension
   cache-extension          =   token [ "=" ( token | quoted-string ) ]
```
   no-cache:
      
      미디어 스트림을 어디에도 캐시해서는 안됨을 나타냅니다. 이를 통해 오리진 서버는 클라이언트 요청에 부실 응답을 리턴하도록 구성된 캐시로도 캐싱을 방지 할 수 있습니다

   public:

      미디어 스트림이 모든 캐시에 의해 캐시 가능함을 나타냅니다.

   private:

      미디어 스트림은 단일 사용자를위한 것이며 공유 캐시에 의해 캐시되지 않아야 함을 나타냅니다. 개인 (비공유) 캐시는 미디어 스트림을 캐시 할 수 있습니다.

   no-transform:

      중간 캐시 (프록시)는 특정 스트림의 미디어 유형을 변환하는 것이 유용 할 수 있습니다. 예를 들어 프록시는 비디오 형식간에 변환하여 캐시 공간을 절약하거나 느린 링크의 트래픽 양을 줄일 수 있습니다. 그러나 이러한 변환이 특정 종류의 응용 프로그램을위한 스트림에 적용된 경우 심각한 운영 문제가 발생할 수 있습니다. 예를 들어, 의료 이미징, 과학적 데이터 분석 및 엔드 투 엔드 인증을 사용하는 응용 프로그램은 모두 원본 엔터티 본문과 비트 단위로 동일한 스트림을받는 데 달려 있습니다. 따라서 응답에 비 변환 지시문이 포함 된 경우 중간 캐시 또는 프록시는 스트림의 인코딩을 변경해서는 안됩니다 (MUST NOT). HTTP와 달리 RTSP는이 시점에서 예를 들어 다른 언어로 번역 할 수 있도록 부분 변환을 제공하지 않습니다

   only-if-cached:

      네트워크 연결 상태가 매우 좋지 않은 경우와 같이 클라이언트는 캐시가 현재 저장된 미디어 스트림 만 반환하고 원본 서버에서 이러한 미디어 스트림을받지 않기를 원할 수 있습니다. 이를 위해 클라이언트는 요청에 캐시 전용 지시문을 포함시킬 수 있습니다. 이 지시어를 수신하면 캐시는 요청의 다른 제약 조건과 일치하는 캐시 된 미디어 스트림을 사용하여 응답하거나 504 (게이트웨이 타임 아웃) 상태로 응답해야합니다. 그러나 캐시 그룹이 내부 연결이 양호한 통합 시스템으로 작동하는 경우 해당 요청이 해당 캐시 그룹 내에서 전달 될 수 있습니다.

   max-stale:

      클라이언트가 만료 시간을 초과 한 미디어 스트림을 기꺼이 수락 함을 나타냅니다. max-stale에 값이 할당되면 클라이언트는 지정된 시간 (초)까지 만료 시간을 초과 한 응답을 기꺼이 수락합니다. max-stale에 값이 지정되지 않으면 클라이언트는 모든 연령의 오래된 응답을 기꺼이 수락합니다.


   min-fresh:

      클라이언트가 최신 수명이 현재 연령에 지정된 시간 (초)을 더한 미디어 스트림을 기꺼이 수락 함을 나타냅니다. 즉, 클라이언트는 최소한 지정된 시간 (초) 동안 새로운 응답을 원합니다.

   must-revalidate:

      캐시가 수신 한 SETUP 응답에 must-revalidate 지시문이있는 경우, 해당 캐시는 원래 서버로 먼저 유효성을 재확인하지 않고 후속 요청에 응답 할 수 없을 때 항목을 사용해서는 안됩니다. 즉, 캐시가 원래 서버의 만기일에 기초하여 캐시 된 응답이 오래되면 캐시는 엔드 투 엔드 유효성 재확인을 수행해야합니다.)
<hr/>

#### 12.9 Conference

이 요청 헤더 필드는 사전 설정된 컨퍼런스와 RTSP 스트림 간의 논리적 연결을 설정합니다. 동일한 RTSP 세션에 대해 회의 ID를 변경해서는 안됩니다.

   Conference = "Conference" ":" conference-id 
   Example:
     Conference: 199702170042.SAA08642@obiwan.arl.wustl.edu%20Starr

컨퍼런스 ID가 유효하지 않은 경우 응답 코드 452 (452 컨퍼런스를 찾을 수 없음)가 리턴됩니다.
<hr/>

#### 12.10 Connection

   See [H14.10]

#### 12.11 Content-Base

   See [H14.11]

#### 12.12 Content-Encoding

   See [H14.12]

#### 12.13 Content-Language

   See [H14.13]
<hr/>


#### 12.14 Content-Length

이 필드에는 메소드 내용의 길이가 포함됩니다 (즉, 마지막 헤더 다음에 나오는 이중 CRLF 이후). HTTP와는 달리 메시지의 헤더 부분을 넘어서 내용을 전달하는 모든 메시지에 포함되어야합니다. 누락 된 경우 기본값 0으로 가정합니다. [H14.14]에 따라 해석됩니다.
<hr/>

#### 12.15 Content-Location

   See [H14.15]

#### 12.16 Content-Type

[H14.18]을 참조하십시오. RTSP에 적합한 컨텐츠 유형은 실제로는 프리젠 테이션 설명 및 매개 변수 값 유형으로 제한 될 수 있습니다.

#### 12.17 CSeq

CSeq 필드는 RTSP 요청-응답 쌍의 시퀀스 번호를 지정합니다. 이 필드는 모든 요청과 응답에 있어야합니다. 주어진 시퀀스 번호를 포함하는 모든 RTSP 요청에 대해 동일한 번호를 가진 해당 응답이 있습니다. 재전송 된 요청에는 원본과 동일한 시퀀스 번호가 포함되어야합니다 (즉, 동일한 요청의 재전송을 위해 시퀀스 번호가 증가하지 않음).

#### 12.18 Date

   See [H14.19].

#### 12.19 Expires

Expires entity-header 필드는 설명 또는 미디어 스트림이 오래된 것으로 간주되는 날짜 및 시간을 제공합니다. 해석은 방법에 따라 다릅니다.

DESCRIBE response:

    Expires 헤더는 설명이 오래된 것으로 간주되는 날짜와 시간을 나타냅니다.

오래된 캐시 항목은 원래 서버 (또는 엔티티의 새로운 사본이있는 중간 캐시)로 먼저 유효성 검증되지 않는 한 캐시 (프록시 캐시 또는 사용자 에이전트 캐시)에 의해 정상적으로 리턴되지 않을 수 있습니다. 만기 모델에 대한 자세한 설명은 섹션 13을 참조하십시오.    만료 필드가 있다고해서 원래 리소스가 해당 시간 전, 후 또는 후에 존재하거나 변경되지 않는다는 것을 의미하지는 않습니다.    형식은 [H3.3]에 HTTP-date에 의해 정의 된 절대 날짜 및 시간입니다. RFC1123 날짜 형식이어야합니다.

      Expires = "Expires" ":" HTTP-date

      An example of its use is
            Expires: Thu, 01 Dec 1994 16:00:00 GMT

RTSP / 1.0 클라이언트 및 캐시는 과거에 발생한 것으로서 (예 : "이미 만료 됨") 특히 유효하지 않은 날짜 형식, 특히 "0"을 처리해야합니다.    응답이 "이미 만료 됨"으로 표시하려면 오리진 서버가 만료 날짜를 사용하여 날짜 헤더 값과 같아야합니다. 응답이 "만료되지 않음"으로 표시하려면 오리진 서버는 응답이 전송 된 날로부터 약 1 년 후에 만료 날짜를 사용해야합니다. RTSP / 1.0 서버는 향후 1 년 이상 만료 날짜를 보내지 않아야합니다.    나중에 캐시 할 수없는 미디어 스트림에서 날짜 값이 일정 시간 인 Expires 헤더 필드가 있으면 캐시 제어 헤더 필드로 다르게 표시되지 않는 한 미디어 스트림이 캐시 가능함을 나타냅니다 (섹션 12.8).
<hr/>

#### 12.20 From

   See [H14.22].

#### 12.21 Host

이 HTTP 요청 헤더 필드는 RTSP에 필요하지 않습니다. 전송되면 자동으로 무시해야합니다.
<hr/>

#### 12.22 If-Match

   See [H14.25].

이 필드는 RTSP 외부 수단 (예 : HTTP)을 통해 페치되는 경우 또는 서버 구현이 설명 사이의 설명의 무결성을 보장하는 경우에 프리젠 테이션 설명의 무결성을 보장하는 데 특히 유용합니다. DESCRIBE 메시지 및 SETUP 메시지의 시간.

식별자는 불투명 식별자이므로 특정 세션 설명 언어에 국한되지 않습니다.
<hr/>

#### 12.23 If-Modified-Since

If-Modified-Since 요청 헤더 필드는 DESCRIBE 및 SETUP 메소드와 함께 사용되어 조건부로 만듭니다. 이 필드에 지정된 시간 이후 요청 된 변형이 수정되지 않은 경우 서버에서 설명이 반환되지 않거나 (DESCRIBE) 스트림이 설정되지 않습니다 (SETUP). 대신 메시지 본문없이 304 (수정되지 않은) 응답이 반환됩니다.

      If-Modified-Since = "If-Modified-Since" ":" HTTP-date

      An example of the field is:
            If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
<hr/>

#### 12.24 Last-Modified

Last-Modified entity-header 필드는 원본 서버가 프레젠테이션 설명 또는 미디어 스트림이 마지막으로 수정되었다고 생각한 날짜와 시간을 나타냅니다. [H14.29]를 참조하십시오. DESCRIBE 또는 ANNOUNCE 메소드의 경우, 헤더 필드는 미디어 스트림의 설정에 대한 설명의 마지막 수정 날짜 및 시간을 나타냅니다
<hr/>

#### 12.25 Location

   See [H14.30].

#### 12.26 Proxy-Authenticate

   See [H14.33].

#### 12.27 Proxy-Require

Proxy-Require 헤더는 프록시가 반드시 지원해야하는 프록시에 민감한 기능을 나타내는 데 사용됩니다. 프록시가 지원하지 않는 프록시 요구 헤더 기능은 지원되지 않는 경우 프록시가 클라이언트에게 부정적으로 승인해야합니다. 서버는이 필드를 요구 필드와 동일하게 취급해야합니다.    이 메시지의 메커니즘과 사용 예에 대한 자세한 내용은 12.32 절을 참조하십시오.
<hr/>

#### 12.28 Public

   See [H14.35].

#### 12.29 Range
이 요청 및 응답 헤더 필드는 시간 범위를 지정합니다.    범위는 여러 단위로 지정할 수 있습니다. 이 사양은 smpte (섹션 3.5), npt (섹션 3.6) 및 클럭 (섹션 3.7) 범위 단위를 정의합니다. RTSP 내에서 바이트 범위 [H14.36.1]는 의미가 없으므로 사용해서는 안됩니다. 헤더에는 작업이 적용되는 시간을 지정하는 시간 매개 변수가 UTC로 포함될 수도 있습니다. Range 헤더를 지원하는 서버는 반드시 NPT 범위 형식을 이해해야하며 SMPTE 범위 형식을 이해해야합니다. Range 응답 헤더는 실제로 재생 또는 녹음되는 시간 범위를 나타냅니다. Range 헤더가 알 수없는 시간 형식으로 제공되면 수신자는 "501 Not Implemented"를 반환해야합니다.

범위는 하한 점을 포함하지만 상한 점을 제외하고 반 개방 간격입니다. 다시 말해, a-b 범위는 시간 a에서 정확히 시작하지만 b 직전에 중지됩니다. 비디오 또는 오디오 프레임과 같은 미디어 장치의 시작 시간 만 관련이 있습니다. 예를 들어, 비디오 프레임이 40ms마다 생성된다고 가정하십시오. 10.0-10.1 범위는 10.0 이상에서 시작하는 비디오 프레임을 포함하고 10.08에서 시작하는 비디오 프레임을 포함하지만 간격을 초과해도 지속됩니다. 반면 10.0-10.08의 범위는 10.08에서 프레임을 제외합니다.
~~~
   Range            = "Range" ":" 1\#ranges-specifier
                          [ ";" "time" "=" utc-time ]
   ranges-specifier = npt-range | utc-range | smpte-range

   Example:
     Range: clock=19960213T143205Z-;time=19970123T143720Z
~~~

이 표기법은 HTTP / 1.1 [2] 바이트 범위 헤더에 사용 된 표기법과 유사합니다. 클라이언트가 미디어 객체에서 발췌를 선택하고 주어진 지점에서 끝으로, 현재 위치에서 지정된 지점으로 재생할 수 있습니다. 서버는 유휴 기간 동안 서버 자원을 유지하지 않을 수도 있지만 나중에 재생 시작을 예약 할 수 있습니다.
 <hr/>


#### 12.30 Referer

[H14.37]을 참조하십시오. URL은 일반적으로 HTTP를 통해 검색되는 프리젠 테이션 설명의 URL을 나타냅니다.

#### 12.31 Retry-After

   See [H14.38].

#### 12.32 Require
Require 헤더는 클라이언트가 지원하거나 지원하지 않는 옵션에 대해 서버에 쿼리하기 위해 클라이언트가 사용합니다. 서버는 지원되지 않는 옵션을 부정적으로 인정하기 위해 지원되지 않는 헤더를 사용하여이 헤더에 응답해야합니다.      이것은 모든 옵션이 양쪽에 의해 이해 될 때 클라이언트-서버 상호 작용이 지연없이 진행되도록하고, 옵션이 이해되지 않으면 (위의 경우와 같이) 느리게 진행되도록하기위한 것입니다. 일치하는 클라이언트-서버 쌍의 경우 상호 작용이 빠르게 진행되어 협상 메커니즘에 필요한 왕복 시간이 절약됩니다. 또한 클라이언트가 서버가 이해하지 못하는 기능을 요구할 때 상태 모호성을 제거합니다.
~~~
   Require =   "Require" ":"  1#option-tag


   Example:
     C->S:   SETUP rtsp://server.com/foo/bar/baz.rm RTSP/1.0
             CSeq: 302
             Require: funky-feature
             Funky-Parameter: funkystuff


     S->C:   RTSP/1.0 551 Option not supported
             CSeq: 302
             Unsupported: funky-feature


     C->S:   SETUP rtsp://server.com/foo/bar/baz.rm RTSP/1.0
             CSeq: 303


     S->C:   RTSP/1.0 200 OK
             CSeq: 303
~~~
이 예에서 "funky-feature"는 가상의 Funky-Parameter 필드가 필요함을 클라이언트에 나타내는 기능 태그입니다. "펑키-피처"와 펑키-파라미터의 관계는 RTSP 교환을 통해 전달되지 않습니다. 그 관계는 "펑키-피처"의 불변 속성이므로 모든 교환과 함께 전송되어서는 안됩니다.

프록시 및 기타 중개 장치는이 분야에서 이해되지 않는 기능을 무시해야합니다. 특정 확장이 중간 장치가이를 지원하도록 요구하는 경우 확장은 대신 프록시 요구 필드에 태그되어야합니다 (섹션 12.27 참조).
<hr/>

#### 12.33 RTP-Info

이 필드는 PLAY 응답에서 RTP 특정 매개 변수를 설정하는 데 사용됩니다.

   url:

      다음 RTP 매개 변수가 해당하는 스트림 URL을 나타냅니다.

   seq:

      스트림의 첫 번째 패킷의 시퀀스 번호를 나타냅니다. 이를 통해 클라이언트는 원하는 패킷을 정상적으로 처리 할 수 있습니다. 클라이언트는이 값을 사용하여 탐색 전에 시작된 패킷을 탐색 후 시작된 패킷과 구별합니다.

   rtptime:
      
      Range 응답 헤더의 시간 값에 해당하는 RTP 타임 스탬프를 나타냅니다. (참고 : 집계 제어의 경우 특정 스트림이 실제로 반환되거나 암시 된 범위 시간 값에 대한 패킷을 생성하지 않을 수 있습니다. 따라서 seq로 표시된 시퀀스 번호를 가진 패킷에 실제로 rtptime으로 표시된 타임 스탬프가 있다고 보장 할 수 없습니다.) 클라이언트는이 값을 사용하여 RTP 시간과 NPT 간의 매핑을 계산합니다.     
 RTP 타임 스탬프에서 NTP 타임 스탬프 (월 클락) 로의 매핑은 RTCP를 통해 사용할 수 있습니다. 그러나이 정보는 RTP 타임 스탬프에서 NPT 로의 매핑을 생성하기에 충분하지 않습니다. 또한이 정보가 필요한 시점 (즉시 시작 또는 검색 후)에 사용 가능하고 안정적으로 전달되도록하기 위해이 맵핑은 RTSP 제어 채널에 배치됩니다.     
 길고 중단되지 않은 프리젠 테이션에 대한 드리프트를 보상하기 위해 RTSP 클라이언트는 매핑을 수행하기 위해 초기 RTCP 발신자 보고서를 사용하여 나중에 NPT를 NTP에 매핑하고 나중에 보고서를 매핑에 대한 드리프트를 확인해야합니다.
~~~
   Syntax:

   RTP-Info        = "RTP-Info" ":" 1#stream-url 1*parameter
   stream-url      = "url" "=" url
   parameter       = ";" "seq" "=" 1*DIGIT
                   | ";" "rtptime" "=" 1*DIGIT
   Example:
     RTP-Info: url=rtsp://foo.com/bar.avi/streamid=0;seq=45102,
               url=rtsp://foo.com/bar.avi/streamid=1;seq=30211
~~~
<hr/>

#### 12.34 Scale

스케일 값 1은 정상 재생 속도 또는 정상 순방향 시청률로 녹화를 나타냅니다. 1이 아닌 경우이 값은 일반 시청률과 관련된 비율에 해당합니다. 예를 들어, 2의 비율은 일반 시청률의 두 배 ( "빨리 감기")를 나타내며 0.5의 비율은 일반 시청률의 절반을 나타냅니다. 즉, 2의 비율은 벽시계 속도의 두 배로 정상적인 재생 시간이 증가합니다. 경과 시간 (벽시계) 1 초마다 2 초의 컨텐츠가 전달됩니다. 음수 값은 반대 방향을 나타냅니다.   

 Speed 매개 변수에서 달리 요청하지 않는 한 데이터 속도는 변경하지 않아야합니다. 스케일 변경의 구현은 서버 및 미디어 유형에 따라 다릅니다. 비디오의 경우, 서버는 예를 들어 키 프레임 또는 선택된 키 프레임 만 전달할 수 있습니다. 오디오의 경우, 피치를 유지하면서 오디오의 시간 스케일을 조정하거나 덜 바람직하게는 오디오 조각을 전달할 수 있습니다.    

서버는 시청률을 근사하려고하지만 지원하는 스케일 값의 범위를 제한 할 수 있습니다. 응답은 반드시 서버가 선택한 실제 스케일 값을 포함해야합니다.    
요청에 Range 매개 변수가 포함 된 경우 새 스케일 값이 해당 시간에 적용됩니다.
~~~
   Scale = "Scale" ":" [ "-" ] 1*DIGIT [ "." *DIGIT ]

   Example of playing in reverse at 3.5 times normal rate:
     Scale: -3.5
~~~
<hr/>

#### 12.35 Speed

이 요청 헤더 필드 매개 변수는 서버가 특정 속도로 클라이언트에 데이터를 전달하도록 요청합니다. 이는 서버의 능력과 주어진 속도로 미디어 스트림을 제공하려는 욕구에 따라 다릅니다. 서버에 의한 구현은 선택 사항입니다. 디폴트는 스트림의 비트 레이트입니다.   
 매개 변수 값은 10 진수 비율로 표시됩니다. 예를 들어, 2.0 값은 데이터가 정상보다 두 배 빠르게 전달됨을 나타냅니다. 속도가 0입니다. 요청에 Range 매개 변수가 포함 된 경우 새 속도 값이 해당 시간에 적용됩니다.
~~~
   Speed = "Speed" ":" 1*DIGIT [ "." *DIGIT ]


   Example:
     Speed: 2.5
~~~

이 필드를 사용하면 데이터 전송에 사용되는 대역폭이 변경됩니다. 더 높거나 낮은 비율로 프리젠 테이션 미리보기가 필요한 특정 상황에서 사용하기위한 것입니다. 구현자는 세션에 대한 대역폭이 미리 RTSP 이외의 방법으로 협상 될 수 있으므로 재협상이 필요할 수 있음을 명심해야합니다. UDP를 통해 데이터를 전달할 때는 RTCP와 같은 수단을 사용하여 패킷 손실률을 추적하는 것이 좋습니다.
<hr/>

#### 12.36 Server

   See [H14.39]

#### 12.37 Session

이 요청 및 응답 헤더 필드는 SETUP 응답에서 미디어 서버에 의해 시작되고 프리젠 테이션 URL에서 TEARDOWN으로 끝나는 RTSP 세션을 식별합니다. 세션 식별자는 미디어 서버에 의해 선택됩니다 (섹션 3.4 참조). 클라이언트가 세션 식별자를 받으면 해당 세션과 관련된 모든 요청에 대해 해당 식별자를 반환해야합니다. 동적으로 생성 된 URL과 같이 세션을 식별하는 다른 방법이있는 경우 서버는 세션 식별자를 설정할 필요가 없습니다.

      Session  = "Session" ":" session-id [ ";" "timeout" "=" delta-seconds ]

제한 시간 매개 변수는 응답 헤더에서만 허용됩니다. 서버는이를 사용하여 활동 부족으로 인해 세션을 닫기 전에 서버가 RTSP 명령 사이에서 대기 할 시간을 표시합니다 (섹션 A 참조). 시간 초과는 초 단위로 측정되며 기본값은 60 초 (1 분)입니다.    

세션 식별자는 전송 세션 또는 연결에서 RTSP 세션을 식별합니다. 둘 이상의 RTSP URL에 대한 제어 메시지는 단일 RTSP 세션 내에서 전송 될 수 있습니다. 따라서 모든 스트림이 동일한 서버에서 온 경우 클라이언트는 프리젠 테이션을 구성하는 많은 스트림을 제어하기 위해 동일한 세션을 사용할 수 있습니다. (섹션 14의 예 참조). 그러나 동일한 클라이언트에서 동일한 URL에 대한 여러 "사용자"세션은 다른 세션 식별자를 사용해야합니다.      

세션 식별자는 동일한 클라이언트에서 오는 동일한 URL에 대한 여러 배달 요청을 구별하는 데 필요합니다.    세션 ID가 유효하지 않으면 응답 454 (세션을 찾을 수 없음)가 리턴됩니다.

12.38 Timestamp
타임 스탬프 일반 헤더는 클라이언트가 요청을 서버에 보낸시기를 설명합니다. 타임 스탬프의 값은 클라이언트에게만 중요하며 모든 타임 스케일을 사용할 수 있습니다. 서버는 정확히 동일한 값을 에코해야하며, 이에 대한 정확한 정보가있는 경우 요청을받은 후 경과 한 시간 (초)을 나타내는 부동 소수점 숫자를 추가해야합니다. 타임 스탬프는 클라이언트가 서버에 대한 왕복 시간을 계산하여 재전송에 대한 시간 초과 값을 조정할 수 있도록 사용합니다.

      Timestamp  = "Timestamp" ":" *(DIGIT) [ "." *(DIGIT) ] [ delay ]
      delay      =  *(DIGIT) [ "." *(DIGIT) ]
<hr/>

#### 12.39 Transport
이 요청 헤더는 사용할 전송 프로토콜을 나타내며 대상 주소, 압축, 멀티 캐스트 TTL (Time-to-Live) 및 단일 스트림의 대상 포트와 같은 매개 변수를 구성합니다. 프리젠 테이션 설명에 의해 아직 결정되지 않은 값을 설정합니다.    
전송은 선호 순서대로 쉼표로 구분됩니다.    

세미콜론으로 구분하여 각 전송에 매개 변수를 추가 할 수 있습니다.    
전송 헤더는 특정 전송 매개 변수를 변경하는 데 사용될 수도 있습니다. 서버는 기존 스트림의 매개 변수 변경을 거부 할 수 있습니다.   
 서버는 실제로 선택된 값을 나타 내기 위해 응답에 전송 응답 헤더를 반환 할 수있다.   
 전송 요청 헤더 필드는 클라이언트가 수용 할 수있는 전송 옵션 목록을 포함 할 수 있습니다. 이 경우 서버는 실제로 선택된 단일 옵션을 반환해야합니다.    
전송 지정자의 구문은 **transport / profile / lower-transport** 입니다.    
"저 전송"매개 변수의 기본값은 프로파일에 따라 다릅니다. RTP / AVP의 경우 기본값은 UDP입니다.    다음은 전송과 관련된 구성 매개 변수입니다.
 

   General parameters:

   unicast | multicast:
      
      유니 캐스트 또는 멀티 캐스트 배달 시도 여부에 대한 상호 배타적 표시. 기본값은 멀티 캐스트입니다. 유니 캐스트 및 멀티 캐스트 전송을 모두 처리 할 수있는 클라이언트는 각각 별도의 매개 변수가있는 두 개의 전체 전송 사양을 포함하여 이러한 기능을 나타내야합니다.

   destination:
      
      스트림이 전송 될 주소입니다. 클라이언트는 대상 매개 변수를 사용하여 멀티 캐스트 주소를 지정할 수 있습니다. 원격 제어 서비스 거부 공격의 의도하지 않은 가해자가되지 않도록 서버는 클라이언트가 서버를 선택하지 않은 주소로 미디어 스트림을 보내도록 허용하기 전에 클라이언트를 인증하고 이러한 시도를 기록해야합니다 (SHOULD). RTSP 명령이 UDP를 통해 실행되는 경우 특히 중요하지만 구현 자체만으로도 클라이언트를 신뢰할 수있는 방법으로 TCP를 사용할 수 없습니다. 서버는 클라이언트가 미디어 명령을 주소 명령과 다른 주소로 보내도록 허용해서는 안됩니다 (SHOULD).

   source:

      스트림의 소스 주소가 RTSP 엔드 포인트 주소 (재생중인 서버 또는 녹음중인 클라이언트)에서 파생 될 수있는 것과 다른 경우 소스를 지정할 수 있습니다.      이 정보는 SDP를 통해서도 이용할 수 있습니다. 그러나 이는 미디어 초기화보다 전송 기능이 더 많기 때문에이 정보의 신뢰할 수있는 소스는 SETUP 응답에 있어야합니다.


   layers:
      
      이 미디어 스트림에 사용될 멀티 캐스트 레이어의 수입니다. 계층은 대상 주소에서 시작하여 연속 주소로 전송됩니다.

   mode:
      
      mode 매개 변수는이 세션에서 지원되는 메소드를 나타냅니다. 유효한 값은 PLAY 및 RECORD입니다. 제공하지 않으면 기본값은 PLAY입니다.

   append:
      
      mode 매개 변수에 RECORD가 포함 된 경우 append 매개 변수는 미디어 데이터가 기존 리소스를 덮어 쓰지 않고 추가해야한다는 것을 나타냅니다. 추가가 요청되고 서버가이를 지원하지 않으면 URI로 식별 된 리소스를 덮어 쓰지 않고 요청을 거부해야합니다. 모드 매개 변수에 RECORD가 없으면 append 매개 변수는 무시됩니다.

   interleaved:

      인터리브 매개 변수는 10.12 절에 정의 된 메커니즘을 사용하여 제어 스트림에 의해 사용되는 프로토콜에서 미디어 스트림과 제어 스트림을 혼합하는 것을 의미한다. 이 인수는 $ 문에서 사용될 채널 번호를 제공합니다. 이 파라미터는 미디어 스트림에 대한 전송 선택이 요구하는 경우, 예를 들어 인터리브 = 4-5의 범위로 지정 될 수있다.      이를 통해 RTP / RTCP를 UDP와 같은 방식으로 처리 할 수 있습니다 (예 : RTP 채널 하나와 RTCP 채널 하나).

   Multicast specific:

   ttl:

          multicast time-to-live

   RTP Specific:

   port:

      이 매개 변수는 멀티 캐스트 세션에 대한 RTP / RTCP 포트 쌍을 제공합니다. 범위로 지정됩니다 (예 : port = 3456-3457).

   client_port:

      이 매개 변수는 클라이언트가 미디어 데이터 및 제어 정보를 수신하도록 선택한 유니 캐스트 RTP / RTCP 포트 쌍을 제공합니다. 범위로 지정됩니다 (예 : client_port = 3456-3457).

   server_port:

      이 매개 변수는 서버가 미디어 데이터 및 제어 정보를 수신하도록 선택한 유니 캐스트 RTP / RTCP 포트 쌍을 제공합니다. 범위로 지정됩니다 (예 : server_port = 3456-3457).

   ssrc:

      ssrc 파라미터는 RTP SSRC [24, Sec. 3] 미디어 서버에서 사용하거나 요청해야하는 값입니다. 이 매개 변수는 유니 캐스트 전송에만 유효합니다. 미디어 스트림과 연관 될 동기화 소스를 식별합니다.
~~~
 Transport           =    "Transport" ":" 1\#transport-spec
   transport-spec      =    transport-protocol/profile[/lower-transport]
                            *parameter
   transport-protocol  =    "RTP"
   profile             =    "AVP"
   lower-transport     =    "TCP" | "UDP"
   parameter           =    ( "unicast" | "multicast" )
                       |    ";" "destination" [ "=" address ]
                       |    ";" "interleaved" "=" channel [ "-" channel ]
                       |    ";" "append"
                       |    ";" "ttl" "=" ttl
                       |    ";" "layers" "=" 1*DIGIT
                       |    ";" "port" "=" port [ "-" port ]
                       |    ";" "client_port" "=" port [ "-" port ]
                       |    ";" "server_port" "=" port [ "-" port ]
                       |    ";" "ssrc" "=" ssrc
                       |    ";" "mode" = <"> 1\#mode <">
   ttl                 =    1*3(DIGIT)
   port                =    1*5(DIGIT)
   ssrc                =    8*8(HEX)
   channel             =    1*3(DIGIT)
   address             =    host
   mode                =    <"> *Method <"> | Method

   Example:
     Transport: RTP/AVP;multicast;ttl=127;mode="PLAY",
                RTP/AVP;unicast;client_port=3456-3457;mode=“PLAY"
~~~

전송 헤더는 단일 RTP 스트림을 설명하는 것으로 제한됩니다. RTSP는 여러 스트림을 단일 엔터티로 제어 할 수도 있습니다. 여러 세션 설명 형식에 의존하지 않고 RTSP의 일부로 만들면 방화벽 설계가 크게 간소화됩니다.
<hr/>

#### 12.40 Unsupported

지원되지 않는 응답 헤더에는 서버에서 지원하지 않는 기능이 나열됩니다. 기능이 프록시 필요 필드 (12.32 절)를 통해 지정된 경우 클라이언트와 서버 사이의 경로에 프록시가있는 경우 프록시는 "551 옵션이 지원되지 않음"이라는 오류 메시지와 함께 메시지 응답을 삽입해야합니다. “.    
사용법 예제는 12.32 절을 참조하십시오.

#### 12.41 User-Agent

   See [H14.42]

#### 12.42 Vary

   See [H14.43]

#### 12.43 Via

   See [H14.44].

#### 12.44 WWW-Authentica

   See [H14.46].
<hr/>

### 13. Caching
HTTP에서는 응답 요청 쌍이 캐시됩니다. RTSP는 그 점에서 크게 다릅니다. DESCRIBE가 리턴하거나 ANNOUNCE에 포함 된 프리젠 테이션 설명을 제외하고 응답을 캐시 할 수 없습니다. (DESCRIBE 및 GET_PARAMETER 이외의 응답은 데이터를 반환하지 않으므로 이러한 요청에는 캐싱이 실제로 문제가되지 않습니다.) 그러나 일반적으로 RTSP와 관련하여 대역 외로 전달되는 연속 미디어 데이터에는 바람직합니다. 세션 설명뿐만 아니라 캐시됩니다.    

SETUP 또는 PLAY 요청을 수신하면 프록시는 연속 미디어 컨텐츠의 최신 사본과 해당 설명이 있는지 확인합니다. SETUP 또는 DESCRIBE 요청을 각각 발행하고 Last-Modified 헤더를 캐시 된 사본의 헤더와 비교하여 사본이 최신인지 여부를 판별 할 수 있습니다. 사본이 최신이 아닌 경우 SETUP 전송 매개 변수를 적절하게 수정하고 요청을 원래 서버로 전달합니다. 그런 다음 PLAY 또는 PAUSE와 같은 후속 제어 명령은 수정되지 않은 프록시를 전달합니다. 프록시는 연속 미디어 데이터를 클라이언트에 전달하면서 나중에 재사용 할 수 있도록 로컬 복사본을 만들 수 있습니다. 캐시에 허용 된 정확한 동작은 12.8 절에 설명 된 캐시 응답 지시문에 의해 제공됩니다. 스트림 설명의 하위 레벨 세부 사항이 오리진 서버에서 변경되었을 수 있으므로 캐시는 현재 요청자에게 스트림을 제공하는 경우 DESCRIBE 요청에 응답해야합니다.   

 RTSP 캐시는 HTTP 캐시와 달리 "cut-through"방식입니다. 캐시는 원본 서버에서 전체 리소스를 검색하지 않고 스트리밍 데이터가 클라이언트로 전달 될 때 스트리밍 데이터를 복사합니다. 따라서 추가 대기 시간이 발생하지 않습니다.    클라이언트에게는 RTSP 프록시 캐시가 일반 미디어 서버처럼 보이고 클라이언트 같은 미디어 원본 서버에는 나타납니다. HTTP 캐시가 캐시하는 오브젝트의 컨텐츠 유형, 컨텐츠 언어 등을 저장해야하는 것처럼 매체 캐시는 프리젠 테이션 설명을 저장해야합니다. 일반적으로 캐시는 프리젠 테이션 설명에서 모든 전송 참조 (즉, 멀티 캐스트 정보)를 제거합니다. 캐시에서 클라이언트로의 데이터 전달과 무관하기 때문입니다. 인코딩에 대한 정보는 동일하게 유지됩니다. 캐시가 캐시 된 미디어 데이터를 변환 할 수 있으면 제공 할 수있는 모든 인코딩 가능성을 가진 새로운 프레젠테이션 설명을 만듭니다.
<hr/>


### 14. Examples
다음 예는 RTSL과 같이 표준이 아닌 스트림 설명 형식을 나타냅니다. 다음 예는 해당 형식에 대한 참조로 사용되지 않습니다.
<hr/>


#### 14.1 Media on Demand (Unicast)
클라이언트 C는 미디어 서버 A (audio.example.com) 및 V (video.example.com)로부터 영화를 요청합니다. 미디어 설명은 웹 서버 (W)에 저장된다. 미디어 설명에는 사용 가능한 코덱, 동적 RTP 페이로드 유형, 프로토콜 스택 및 언어 또는 저작권 제한과 같은 콘텐츠 정보를 포함하여 프레젠테이션 및 모든 스트림에 대한 설명이 포함되어 있습니다. 또한 영화의 타임 라인에 대한 표시를 제공 할 수도 있습니다.    
이 예제에서 클라이언트는 영화의 마지막 부분에만 관심이 있습니다.
~~~
     C->W: GET /twister.sdp HTTP/1.1
           Host: www.example.com
           Accept: application/sdp


     W->C: HTTP/1.0 200 OK
           Content-Type: application/sdp
           v=0
           o=- 2890844526 2890842807 IN IP4 192.16.24.202
           s=RTSP Session
           m=audio 0 RTP/AVP 0
           a=control:rtsp://audio.example.com/twister/audio.en
           m=video 0 RTP/AVP 31
           a=control:rtsp://video.example.com/twister/video


     C->A: SETUP rtsp://audio.example.com/twister/audio.en RTSP/1.0
           CSeq: 1
           Transport: RTP/AVP/UDP;unicast;client_port=3056-3057


     A->C: RTSP/1.0 200 OK
           CSeq: 1
           Session: 12345678
           Transport: RTP/AVP/UDP;unicast;client_port=3056-3057;
                      server_port=5000-5001


     C->V: SETUP rtsp://video.example.com/twister/video RTSP/1.0
           CSeq: 1
           Transport: RTP/AVP/UDP;unicast;client_port=3058-3059


     V->C: RTSP/1.0 200 OK
           CSeq: 1
           Session: 23456789
           Transport: RTP/AVP/UDP;unicast;client_port=3058-3059;
                      server_port=5002-5003


     C->V: PLAY rtsp://video.example.com/twister/video RTSP/1.0
           CSeq: 2
           Session: 23456789
           Range: smpte=0:10:00-


     V->C: RTSP/1.0 200 OK
           CSeq: 2
           Session: 23456789
           Range: smpte=0:10:00-0:20:00
           RTP-Info: url=rtsp://video.example.com/twister/video;
             seq=12312232;rtptime=78712811


     C->A: PLAY rtsp://audio.example.com/twister/audio.en RTSP/1.0
           CSeq: 2
           Session: 12345678
           Range: smpte=0:10:00-


     A->C: RTSP/1.0 200 OK
           CSeq: 2
           Session: 12345678
           Range: smpte=0:10:00-0:20:00
           RTP-Info: url=rtsp://audio.example.com/twister/audio.en;
             seq=876655;rtptime=1032181


     C->A: TEARDOWN rtsp://audio.example.com/twister/audio.en RTSP/1.0
           CSeq: 3
           Session: 12345678


     A->C: RTSP/1.0 200 OK
           CSeq: 3


     C->V: TEARDOWN rtsp://video.example.com/twister/video RTSP/1.0
           CSeq: 3
           Session: 23456789


     V->C: RTSP/1.0 200 OK
           CSeq: 3
~~~
오디오 및 비디오 트랙이 서로 다른 두 서버에 있고 약간 다른 시간에 시작하여 서로 표류 할 수 있지만 클라이언트는 표준 RTP 방법, 특히 RTCP 발신자에 포함 된 시간 척도를 사용하여 두 가지를 동기화 할 수 있습니다. 보고서.
<hr/>
     
#### 14.2 Streaming of a Container file

이 예의 목적으로, 컨테이너 파일은 동일한 최종 사용자 프리젠 테이션과 관련된 여러 연속 미디어 유형이 존재하는 스토리지 엔티티입니다. 실제로 컨테이너 파일은 RTSP 프리젠 테이션을 나타내며 각 구성 요소는 RTSP 스트림입니다.    
컨테이너 파일은 이러한 프레젠테이션을 저장하는 데 널리 사용되는 수단입니다.    
구성 요소는 독립 스트림으로 전송되지만 서버 쪽에서 해당 스트림에 대한 공통 컨텍스트를 유지하는 것이 바람직합니다.      
이를 통해 서버는 단일 스토리지 핸들을 쉽게 열 수 있습니다. 또한 서버에 의해 스트림 우선 순위가 지정된 경우 모든 스트림을 동일하게 처리 할 수 있습니다.    
프리젠 테이션 작성자는 결합 된 미디어 프리젠 테이션의 예술적 효과를 보존하기 위해 클라이언트에 의한 스트림의 선택적인 검색을 방지하기를 원할 수도있다. 유사하게, 그러한 밀접하게 묶인 프리젠 테이션에서, 집합 URL을 사용하여 단일 제어 메시지를 통해 모든 스트림을 제어 할 수있는 것이 바람직하다.    
다음은 단일 RTSP 세션을 사용하여 여러 스트림을 제어하는 예입니다. 또한 집계 URL 사용을 보여줍니다.    클라이언트 C는 미디어 서버 M에게 프리젠 테이션을 요청합니다. 영화는 컨테이너 파일에 저장됩니다. 클라이언트가 컨테이너 파일에 대한 RTSP URL을 얻었습니다.
~~~
     C->M: DESCRIBE rtsp://foo/twister RTSP/1.0
           CSeq: 1


     M->C: RTSP/1.0 200 OK
           CSeq: 1
           Content-Type: application/sdp
           Content-Length: 164

           v=0
           o=- 2890844256 2890842807 IN IP4 172.16.2.93
           s=RTSP Session
           i=An Example of RTSP Session Usage
           a=control:rtsp://foo/twister
           t=0 0
           m=audio 0 RTP/AVP 0
           a=control:rtsp://foo/twister/audio
           m=video 0 RTP/AVP 26
           a=control:rtsp://foo/twister/video


     C->M: SETUP rtsp://foo/twister/audio RTSP/1.0
           CSeq: 2
           Transport: RTP/AVP;unicast;client_port=8000-8001


     M->C: RTSP/1.0 200 OK
           CSeq: 2
           Transport: RTP/AVP;unicast;client_port=8000-8001;
                      server_port=9000-9001
           Session: 12345678


     C->M: SETUP rtsp://foo/twister/video RTSP/1.0
           CSeq: 3
           Transport: RTP/AVP;unicast;client_port=8002-8003
           Session: 12345678


     M->C: RTSP/1.0 200 OK
           CSeq: 3
           Transport: RTP/AVP;unicast;client_port=8002-8003;
                      server_port=9004-9005
           Session: 12345678


     C->M: PLAY rtsp://foo/twister RTSP/1.0
           CSeq: 4
           Range: npt=0-
           Session: 12345678


     M->C: RTSP/1.0 200 OK
           CSeq: 4
           Session: 12345678
           RTP-Info: url=rtsp://foo/twister/video;
             seq=9810092;rtptime=3450012


     C->M: PAUSE rtsp://foo/twister/video RTSP/1.0
           CSeq: 5
           Session: 12345678


     M->C: RTSP/1.0 460 Only aggregate operation allowed
           CSeq: 5


     C->M: PAUSE rtsp://foo/twister RTSP/1.0
           CSeq: 6
           Session: 12345678


     M->C: RTSP/1.0 200 OK
           CSeq: 6
           Session: 12345678


     C->M: SETUP rtsp://foo/twister RTSP/1.0
           CSeq: 7
           Transport: RTP/AVP;unicast;client_port=10000


     M->C: RTSP/1.0 459 Aggregate operation not allowed
           CSeq: 7
~~~

첫 번째 실패 사례에서 클라이언트는 프레젠테이션의 한 스트림 (이 경우 비디오)을 일시 중지하려고합니다. 서버에서 해당 프레젠테이션을 할 수 없습니다. 두 번째 경우, 집합 URL은 SETUP에 사용되지 않을 수 있으며 전송 매개 변수를 설정하기 위해 스트림 당 하나의 제어 메시지가 필요합니다.      이렇게하면 전송 헤더의 구문이 단순 해지고 방화벽을 통해 전송 정보를 쉽게 구문 분석 할 수 있습니다.
<hr/>

#### 14.3 Single Stream Container Files
일부 RTSP 서버는 모든 파일을 "컨테이너 파일"인 것처럼 취급하지만 다른 서버는 이러한 개념을 지원하지 않을 수 있습니다. 이 때문에 클라이언트는 항상 일관성있는 URL을 사용할 수 있다고 가정하지 않고 요청 URL에 대한 세션 설명에 명시된 규칙을 사용해야합니다. 다음은 멀티 스트림 서버가 단일 스트림 파일을 제공하는 방법에 대한 예입니다.

          Accept: application/x-rtsp-mh, application/sdp
          CSeq: 1


    S->C  RTSP/1.0 200 OK
          CSeq: 1
          Content-base: rtsp://foo.com/test.wav/
          Content-type: application/sdp
          Content-length: 48


          v=0
          o=- 872653257 872653257 IN IP4 172.16.2.187
          s=mu-law wave file
          i=audio test
          t=0 0
          m=audio 0 RTP/AVP 0
          a=control:streamid=0


    C->S  SETUP rtsp://foo.com/test.wav/streamid=0 RTSP/1.0
          Transport: RTP/AVP/UDP;unicast;
                     client_port=6970-6971;mode=play
          CSeq: 2


    S->C  RTSP/1.0 200 OK
          Transport: RTP/AVP/UDP;unicast;client_port=6970-6971;
                     server_port=6970-6971;mode=play
          CSeq: 2
          Session: 2034820394


    C->S  PLAY rtsp://foo.com/test.wav RTSP/1.0
          CSeq: 3
          Session: 2034820394


    S->C  RTSP/1.0 200 OK
          CSeq: 3
          Session: 2034820394
          RTP-Info: url=rtsp://foo.com/test.wav/streamid=0;
            seq=981888;rtptime=3781123
SETUP 명령에서 다른 URL을 확인한 다음 PLAY 명령에서 집계 URL로 다시 전환하십시오. 집계 제어가 가능한 여러 개의 스트림이있는 경우에는 완벽하게 이해되지만 스트림 수가 하나 인 특수한 경우에는 직관적이지 않습니다.    
이 특별한 경우 서버는 다음을 전송하는 구현을 용서하는 것이 좋습니다.

    C->S  PLAY rtsp://foo.com/test.wav/streamid=0 RTSP/1.0
          CSeq: 3

최악의 경우 서버는 다음을 다시 보내야합니다.

    S->C  RTSP/1.0 460 Only aggregate operation allowed
          CSeq: 3

One would also hope that server implementations are also forgiving of the following:

    C->S  SETUP rtsp://foo.com/test.wav RTSP/1.0
          Transport: rtp/avp/udp;client_port=6970-6971;mode=play
          CSeq: 2

이 파일에는 하나의 스트림 만 있기 때문에 이것이 의미하는 것은 모호하지 않습니다.

#### 14.4 Live Media Presentation Using Multicast
미디어 서버 M은 멀티 캐스트 주소와 포트를 선택합니다. 여기서는 웹 서버가 전체 설명에 대한 포인터 만 포함하고 미디어 서버 M은 전체 설명을 유지한다고 가정합니다.

     C->W: GET /concert.sdp HTTP/1.1
           Host: www.example.com


     W->C: HTTP/1.1 200 OK
           Content-Type: application/x-rtsl


           <session>
             <track src="rtsp://live.example.com/concert/audio">
           </session>


     C->M: DESCRIBE rtsp://live.example.com/concert/audio RTSP/1.0
           CSeq: 1


     M->C: RTSP/1.0 200 OK
           CSeq: 1
           Content-Type: application/sdp
           Content-Length: 44
           v=0
           o=- 2890844526 2890842807 IN IP4 192.16.24.202
           s=RTSP Session
           m=audio 3456 RTP/AVP 0
           a=control:rtsp://live.example.com/concert/audio
           c=IN IP4 224.2.0.1/16


     C->M: SETUP rtsp://live.example.com/concert/audio RTSP/1.0
           CSeq: 2
           Transport: RTP/AVP;multicast

     M->C: RTSP/1.0 200 OK
           CSeq: 2
           Transport: RTP/AVP;multicast;destination=224.2.0.1;
                      port=3456-3457;ttl=16
           Session: 0456804596

     C->M: PLAY rtsp://live.example.com/concert/audio RTSP/1.0
           CSeq: 3
           Session: 0456804596

     M->C: RTSP/1.0 200 OK
           CSeq: 3
           Session: 0456804596
<hr/>

#### 14.5 Playing media into an existing session

회의 참가자 C는 미디어 서버 M이 데모 테이프를 기존 회의로 재생하도록하고 싶습니다. C는 미디어 서버에 네트워크 주소와 암호화 키가 이미 컨퍼런스에서 제공되었으므로 서버에서 선택해서는 안됨을 나타냅니다.    이 예제는 간단한 ACK 응답을 생략합니다.

     C->M: DESCRIBE rtsp://server.example.com/demo/548/sound RTSP/1.0
           CSeq: 1
           Accept: application/sdp


     M->C: RTSP/1.0 200 1 OK
           Content-type: application/sdp
           Content-Length: 44


           v=0
           o=- 2890844526 2890842807 IN IP4 192.16.24.202
           s=RTSP Session
           i=See above
           t=0 0
           m=audio 0 RTP/AVP 0


     C->M: SETUP rtsp://server.example.com/demo/548/sound RTSP/1.0
           CSeq: 2
           Transport: RTP/AVP;multicast;destination=225.219.201.15;
                      port=7000-7001;ttl=127
           Conference: 199702170042.SAA08642@obiwan.arl.wustl.edu%20Starr


     M->C: RTSP/1.0 200 OK
           CSeq: 2
           Transport: RTP/AVP;multicast;destination=225.219.201.15;
                      port=7000-7001;ttl=127
           Session: 91389234234
           Conference: 199702170042.SAA08642@obiwan.arl.wustl.edu%20Starr


     C->M: PLAY rtsp://server.example.com/demo/548/sound RTSP/1.0
           CSeq: 3
           Session: 91389234234


     M->C: RTSP/1.0 200 OK
           CSeq: 3
<hr/>

#### 14.6 Recording

회의 참가자 클라이언트 (C)는 미디어 서버 (M)에게 회의의 오디오 및 비디오 부분을 기록하도록 요청한다. 클라이언트는 ANNOUNCE 메소드를 사용하여 기록 된 세션에 대한 메타 정보를 서버에 제공합니다.



     C->M: ANNOUNCE rtsp://server.example.com/meeting RTSP/1.0
           CSeq: 90
           Content-Type: application/sdp
           Content-Length: 121


           v=0
           o=camera1 3080117314 3080118787 IN IP4 195.27.192.36
           s=IETF Meeting, Munich - 1
           i=The thirty-ninth IETF meeting will be held in Munich, Germany
           u=http://www.ietf.org/meetings/Munich.html
           e=IETF Channel 1 <ietf39-mbone@uni-koeln.de>
           p=IETF Channel 1 +49-172-2312 451
           c=IN IP4 224.0.1.11/127
           t=3080271600 3080703600
           a=tool:sdr v2.4a6
           a=type:test
           m=audio 21010 RTP/AVP 5
           c=IN IP4 224.0.1.11/127
           a=ptime:40
           m=video 61010 RTP/AVP 31
           c=IN IP4 224.0.1.12/127


     M->C: RTSP/1.0 200 OK
           CSeq: 90


     C->M: SETUP rtsp://server.example.com/meeting/audiotrack RTSP/1.0
           CSeq: 91
           Transport: RTP/AVP;multicast;destination=224.0.1.11;
                      port=21010-21011;mode=record;ttl=127



     M->C: RTSP/1.0 200 OK
           CSeq: 91
           Session: 50887676
           Transport: RTP/AVP;multicast;destination=224.0.1.11;
                      port=21010-21011;mode=record;ttl=127


     C->M: SETUP rtsp://server.example.com/meeting/videotrack RTSP/1.0
           CSeq: 92
           Session: 50887676
           Transport: RTP/AVP;multicast;destination=224.0.1.12;
                      port=61010-61011;mode=record;ttl=127


     M->C: RTSP/1.0 200 OK
           CSeq: 92
           Transport: RTP/AVP;multicast;destination=224.0.1.12;
                      port=61010-61011;mode=record;ttl=127


     C->M: RECORD rtsp://server.example.com/meeting RTSP/1.0
           CSeq: 93
           Session: 50887676
           Range: clock=19961110T1925-19961110T2015


     M->C: RTSP/1.0 200 OK
           CSeq: 93
<hr/>

### 15. Syntax
RTSP 구문은 RFC 2068에서 사용되는 BNF (Augmented Backus-Naur form)에 설명되어 있습니다 [2].
<hr/>

#### 15.1 Base Syntax

      OCTET              =      <any 8-bit sequence of data>
      CHAR               =      <any US-ASCII character (octets 0 - 127)>
      UPALPHA            =      <any US-ASCII uppercase letter "A".."Z">
      LOALPHA            =      <any US-ASCII lowercase letter "a".."z">
      ALPHA              =      UPALPHA | LOALPHA


      DIGIT              =      <any US-ASCII digit "0".."9">
      CTL                =      <any US-ASCII control character
                                    (octets 0 - 31) and DEL (127)>
      CR                 =      <US-ASCII CR, carriage return (13)>
      LF                 =      <US-ASCII LF, linefeed (10)>


      SP                 =      <US-ASCII SP, space (32)>
      HT                 =      <US-ASCII HT, horizontal-tab (9)>
      <">                =      <US-ASCII double-quote mark (34)>
      CRLF               =      CR LF
      LWS                =      [CRLF] 1*( SP | HT )
      TEXT               =      <any OCTET except CTLs>
      tspecials          =      "(" | ")" | "<" | ">" | "@"
                        |       "," | ";" | ":" | "\" | <">
                        |       "/" | "[" | "]" | "?" | "="
                        |       "{" | "}" | SP | HT


      token              =      1*<any CHAR except CTLs or tspecials>
      quoted-string      =      ( <"> *(qdtext) <"> )
      qdtext             =      <any TEXT except <">>
      quoted-pair        =      "\" CHAR


      message-header     =      field-name ":" [ field-value ] CRLF
      field-name         =      token
      field-value        =      *( field-content | LWS )
      field-content      =      <the OCTETs making up the field-value and
                                    consisting of either *TEXT or
                                    combinations of token, tspecials, and
                                    quoted-string>


      safe               =  "\$" | "-" | "_" | "." | "+"
      extra              =  "!" | "*" | "$'$" | "(" | ")" | ","


      hex                =  DIGIT | "A" | "B" | "C" | "D" | "E" | "F" |
                              "a" | "b" | "c" | "d" | "e" | "f"
      escape             =  "\%" hex hex
      reserved           =  ";" | "/" | "?" | ":" | "@" | "&" | "="


      unreserved         =  alpha | digit | safe | extra
      xchar              =  unreserved | reserved | escape
<hr/>

### 16. Security Considerations

RTSP 서버와 HTTP 서버의 구문 및 사용법이 유사하기 때문에 [H15]에 요약 된 보안 고려 사항이 적용됩니다. 구체적으로 다음 사항에 유의하십시오.

   Authentication Mechanisms:

      RTSP와 HTTP는 일반적인 인증 체계를 공유하므로 인증과 관련하여 동일한 처방을 따라야합니다. 클라이언트 인증 문제에 대해서는 [H15.1], 다중 인증 메커니즘 지원에 관한 문제는 [H15.2]를 참조하십시오.

   Abuse of Server Log Information:

      RTSP와 HTTP 서버는 아마도 유사한 로깅 메커니즘을 가질 것이므로 해당 로그의 내용을 보호 할 때 동일하게 보호해야하므로 서버 사용자의 개인 정보를 보호해야합니다. 서버 로그에 관한 HTTP 서버 권장 사항은 [H15.3]을 참조하십시오.

   Transfer of Sensitive Information:

      RTSP를 통해 전송 된 정보가 일반적으로 HTTP를 통해 전송 된 정보보다 덜 민감한 것으로 생각할 이유가 없습니다. 따라서 데이터 개인 정보 보호 및 사용자 개인 정보 보호와 관련된 모든 예방 조치는 RTSP 클라이언트, 서버 및 프록시의 구현 자에게 적용됩니다. 자세한 내용은 [H15.4]를 참조하십시오.

   Attacks Based On File and Path Names:

      RTSP URL은 반드시 파일 시스템 의미를 갖지 않는 불투명 한 핸들이지만, 많은 구현이 요청 URL의 일부를 파일 시스템 호출로 직접 변환 할 것으로 예상됩니다. 이러한 경우 파일 시스템은 경로 구성 요소에서 ".."확인과 같이 [H15.5]에 요약 된주의 사항을 따라야합니다.

   Personal Information:

      RTSP 클라이언트는 종종 HTTP 클라이언트와 동일한 정보 (사용자 이름, 위치 등)를 소유하므로 동일해야합니다. 추가 권장 사항은 [H15.6]을 참조하십시오.

   Privacy Issues Connected to Accept Headers:

      RTSP에는 HTTP에서와 동일한 "Accept"헤더가 존재할 수 있으므로 [H15.7]에 요약 된 것과 동일한 경고를 사용해야합니다.

   DNS Spoofing:

      아마도 HTTP 세션에 비해 RTSP 세션과 관련된 연결 시간이 길어질수록 RTSP 클라이언트 DNS 최적화는 덜 널리 퍼질 것입니다.           
      그럼에도 불구하고 [H15.8]에 제공된 권장 사항은 여전히 단일 사용을 넘어 DNS-to-IP 매핑에 의존하려는 모든 구현과 관련이 있습니다.

   Location Headers and Spoofing:
      
      단일 서버가 서로를 신뢰하지 않는 여러 조직을 지원하는 경우 해당 조직의 통제하에 생성 된 응답에서 Location 및 Content-Location 헤더 값을 확인하여 서버가 그들은 권한이 없습니다. ([H15.9])    현재 HTTP 사양 (이 문서 작성 시점의 RFC 2068 [2])의 권장 사항 외에도 향후 HTTP 사양은 보안 문제에 대한 추가 지침을 제공 할 수 있습니다.    다음은 RTSP 구현에 대한 추가 고려 사항입니다.

   Concentrated denial-of-service attack:
      
      이 프로토콜은 원격 제어 서비스 거부 공격에 대한 기회를 제공합니다. 공격자는 SETUP 요청에서 하나 이상의 IP 주소를 대상으로 지정하여 트래픽 흐름을 시작할 수 있습니다. 이 경우 공격자의 IP 주소를 알 수 있지만 더 많은 공격을 방지하거나 공격자의 신원을 확인하는 데 항상 유용한 것은 아닙니다. 따라서 RTSP 서버는 서버가 RTSP 인증 메커니즘 (바람직하게는 다이제스트 또는 더 강력한)을 사용하는 알려진 사용자의 데이터베이스 또는 다른 보안 수단에 대해 클라이언트의 신원을 확인한 경우 RTSP 시작 트래픽 흐름에 대한 클라이언트 지정 대상 만 허용해야합니다 (SHOULD). .

   Session hijacking:

      전송 계층 연결과 RTSP 세션 간에는 관계가 없기 때문에 악의적 인 클라이언트가 임의의 세션 식별자로 요청을 발행하여 의심없는 클라이언트에 영향을 줄 수 있습니다. 서버는 대규모의 무작위 및 비 순차 세션 식별자를 사용하여 이러한 종류의 공격 가능성을 최소화해야합니다 (SHOULD).

   Authentication:
      
      서버는 기본 인증과 다이제스트 인증을 모두 구현해야한다. 제어 메시지에 대해보다 엄격한 보안이 필요한 환경에서는 RTSP 제어 스트림이 암호화 될 수 있습니다.

   Stream issues:
      
      RTSP는 스트림 제어만을 제공합니다. 스트림 전달 문제는이 섹션이나이 메모의 나머지 부분에서는 다루지 않습니다. RTSP 구현은 RTP, IP 멀티 캐스트, RSVP 및 IGMP와 같은 다른 프로토콜에 의존 할 가능성이 높으며 해당 사양 및 기타 해당 사양에서 제기 된 보안 고려 사항을 해결해야합니다.

   Persistently suspicious behavior:
      
      RTSP 서버는 보안 위험으로 간주되는 단일 동작 인스턴스를 수신하면 오류 코드 403 (금지됨)을 반환해야합니다. RTSP 서버는 또한 약점과 진입 점에 대해 서버를 검사하려는 시도를 알고 로컬 보안 정책을 위반하는 것으로 간주되는 추가 요청 클라이언트를 임의로 연결 해제하고 무시할 수 있습니다.
<hr/>

#### Appendix A: RTSP Protocol State Machines
RTSP 클라이언트 및 서버 상태 시스템은 RTSP 세션 초기화부터 RTSP 세션 종료까지 프로토콜의 동작을 설명합니다.    
상태는 개체별로 정의됩니다. 개체는 스트림 URL과 RTSP 세션 식별자로 고유하게 식별됩니다. 여러 스트림으로 구성된 RTSP 프리젠 테이션을 나타내는 집계 URL을 사용하는 모든 요청 / 응답은 모든 스트림의 개별 상태에 영향을 미칩니다. 예를 들어, 프레젠테이션 / movie에 / movie / audio 및 / movie / video라는 두 개의 스트림이 포함 된 경우    

다음 명령 :

     PLAY rtsp://foo.com/movie RTSP/1.0
     CSeq: 559
     Session: 12345678

영화 / 오디오 및 영화 / 비디오의 상태에 영향을줍니다.      
이 예제는 URL의 스트림 또는 파일 시스템과의 관계를 나타내는 표준 방법을 의미하지 않습니다. 3.2 절을 참조하십시오.    
OPTIONS, ANNOUNCE, DESCRIBE, GET_PARAMETER, SET_PARAMETER 요청은 클라이언트 또는 서버 상태에 영향을 미치지 않으므로 상태 테이블에 나열되지 않습니다.

#### A.1 Client State Machine
 The client can assume the following states:
~~~
   Init:
          SETUP has been sent, waiting for reply.

   Ready:
          SETUP reply received or PAUSE reply received while in Playing
          state.

   Playing:
          PLAY reply received

   Recording:
          RECORD reply received
~~~

일반적으로 클라이언트는 요청에 대한 응답을 수신하면 상태를 변경합니다. 일부 요청은 향후 시간이나 위치 (예 : PAUSE)에서 유효하며 상태도 그에 따라 변경됩니다. 오브젝트에 명시 적 SETUP이 필요하지 않은 경우 (예 : 멀티 캐스트 그룹을 통해 사용 가능) 상태는 준비 상태에서 시작됩니다. 이 경우 준비 및 재생의 두 가지 상태 만 있습니다. 요청 된 범위의 끝에 도달하면 클라이언트는 상태를 재생 / 녹음에서 준비로 변경합니다.    

"다음 상태"열은 성공 응답 (2xx)을 수신 한 후 가정 된 상태를 나타냅니다. 요청이 상태 코드 3xx를 생성하면 상태는 Init가되고 상태 코드 4xx는 상태를 변경하지 않습니다. 각 상태에 대해 나열되지 않은 메시지는 위에 나열된대로 상태에 영향을 미치지 않는 메시지를 제외하고 해당 상태의 클라이언트가 발행해서는 안됩니다 (MUST NOT). 서버에서 REDIRECT를받는 것은 서버에서 3xx 리디렉션 상태를받는 것과 같습니다.

~~~
   state       message sent     next state after response
   Init        SETUP            Ready
               TEARDOWN         Init
   Ready       PLAY             Playing
               RECORD           Recording
               TEARDOWN         Init
               SETUP            Ready
   Playing     PAUSE            Ready
               TEARDOWN         Init
               PLAY             Playing
               SETUP            Playing (changed transport)
   Recording   PAUSE            Ready
               TEARDOWN         Init
               RECORD           Recording
               SETUP            Recording (changed transport)
~~~
<hr/>

#### A.2 Server State Machine
~~~
   The server can assume the following states:

   Init:
          The initial state, no valid SETUP has been received yet.

   Ready:
          Last SETUP received was successful, reply sent or after
          playing, last PAUSE received was successful, reply sent.

   Playing:
          Last PLAY received was successful, reply sent. Data is being
          sent.

   Recording:
          The server is recording media data.
~~~

일반적으로 서버는 요청 수신시 상태를 변경합니다. 서버가 재생 중 또는 녹음 중 상태이고 유니 캐스트 모드 인 경우 클라이언트에서 정의 된 간격 동안 RTCP 보고서 또는 RTSP 명령과 같은 "웰니스"정보를받지 못하면 RTSP 세션을 초기화로 되돌리고 해제 할 수 있습니다. 기본값은 1 분입니다. 서버는 세션 응답 헤더에 다른 시간 초과 값을 선언 할 수 있습니다 (섹션 12.37). 서버가 Ready (준비) 상태 인 경우 1 분 이상의 간격으로 RTSP 요청을받지 않으면 Init (복귀)로 되돌릴 수 있습니다. 일부 요청 (예 : PAUSE)은 나중에 또는 위치에서 유효 할 수 있으며 적절한 시간에 서버 상태가 변경 될 수 있습니다. 서버는 클라이언트가 요청한 범위의 끝에서 재생 중 또는 녹음 중 상태에서 준비 상태로 돌아갑니다.    

REDIRECT 메시지는 전송 될 때 리디렉션이 적용되는시기를 지정하는 Range 헤더가없는 한 즉시 적용됩니다. 이 경우 서버 상태도 적절한 시간에 변경됩니다.    

객체에 명시적인 SETUP이 필요하지 않은 경우 상태는 Ready에서 시작하며 Ready와 Playing의 두 가지 상태 만 있습니다.    

"다음 상태"열은 성공 응답 (2xx)을 보낸 후 가정 된 상태를 나타냅니다. 요청 결과 상태 코드가 3xx이면 상태는 Init가됩니다. 4xx의 상태 코드는 변경되지 않습니다.

     state           message received  next state
     Init            SETUP             Ready
                     TEARDOWN          Init
     Ready           PLAY              Playing
                     SETUP             Ready
                     TEARDOWN          Init
                     RECORD            Recording
     Playing         PLAY              Playing
                     PAUSE             Ready
                     TEARDOWN          Init
                     SETUP             Playing
     Recording       RECORD            Recording
                     PAUSE             Ready
                     TEARDOWN          Init
                     SETUP             Recording

<hr/>

#### Appendix B: Interaction with RTP
RTSP를 통해 미디어 클라이언트는 선택된 비 연속 미디어 프리젠 테이션 섹션을 제어하여 RTP 미디어 레이어를 사용하여 해당 스트림을 렌더링 할 수 있습니다 [24]. RTP 스트림을 렌더링하는 미디어 계층은 NPT의 점프에 영향을받지 않아야합니다. 따라서 RTP 시퀀스 번호와 RTP 타임 스탬프는 NPT 점프에서 연속적이고 단조로운 것이어야합니다.    

예를 들어, 클럭 주파수 8000Hz, 패킷 화 간격 100ms 및 초기 시퀀스 번호 및 타임 스탬프가 0이라고 가정합니다. 먼저 NPT 10 ~ 15를 재생 한 다음 건너 뛰고 NPT 18 ~ 20을 재생합니다. 첫 번째 세그먼트는 시퀀스 번호가 0 ~ 49이고 타임 스탬프가 0 ~ 39,200 인 RTP 패킷으로 표시됩니다. 두 번째 세그먼트는 시퀀스 번호가 50-69이고 타임 스탬프가 40,000-55,200 인 RTP 패킷으로 구성됩니다.      

RTSP 클라이언트는 RTP 미디어 에이전트와 통신 할 수 있다고 가정 할 수 없습니다. 두 프로세스는 독립적 인 프로세스 일 수 있습니다. RTP 타임 스탬프에 NPT와 동일한 간격이 표시되면 미디어 에이전트는 프레젠테이션에 일시 중지가 있다고 가정합니다. NPT의 점프가 충분히 크면 RTP 타임 스탬프가 롤오버 될 수 있으며 미디어 에이전트는 이후 패킷이 방금 재생 된 패킷의 복제본이라고 생각할 수 있습니다.      

특정 데이터 유형의 경우 RTSP 계층과 RTP 계층 간의 긴밀한 통합이 필요합니다. 이것은 결코 위의 제한을 배제하지 않습니다. 결합 된 RTSP / RTP 미디어 클라이언트는 RTP-Info 필드를 사용하여 수신 RTP 패킷이 검색 전후에 전송되었는지 여부를 결정해야합니다.    
지속적인 오디오를 위해 서버는 새로운 PLAY 요청을 시작할 때 RTP 마커 비트를 설정해야합니다. 이를 통해 클라이언트는 재생 지연 적응을 수행 할 수 있습니다.    

스케일링 (섹션 12.34 참조)의 경우 RTP 타임 스탬프는 재생 타이밍과 일치해야합니다. 예를 들어, 2의 스케일과 1의 속도 (섹션 12.35)로 초당 30 프레임으로 녹화 된 비디오를 재생할 때 서버는 매 초마다 프레임을 삭제하여 프레임 당 3,000의 일반 타임 스탬프 간격으로 비디오 패킷을 유지하고 전달합니다. NPT는 각 비디오 프레임마다 1/15 초씩 증가합니다.    

클라이언트는 재배치 후 도착한 첫 번째 패킷의 RTP 타임 스탬프 값을 기록하여 NPT를 올바르게 표시 할 수 있습니다. RTP-Info (섹션 12.33) 헤더의 시퀀스 파라미터는 다음 세그먼트의 첫 번째 시퀀스 번호를 제공합니다.
<hr/>


#### Appendix C: Use of SDP for RTSP Session Descriptions
세션 설명 프로토콜 (SDP, RFC 2327 [6])은 RTSP에서 스트림 또는 프리젠 테이션을 설명하는 데 사용될 수 있습니다. 이러한 사용은 다음에 대한 액세스 및 인코딩 수단을 지정하는 것으로 제한됩니다.

   aggregate control:

      집계 제어에 사용할 수없는 하나 이상의 서버의 스트림으로 구성된 프리젠 테이션입니다. 이러한 설명은 일반적으로 HTTP 또는 기타 비 RTSP 수단으로 검색됩니다. 그러나 ANNOUNCE 메소드와 함께 수신 될 수 있습니다.

   non-aggregate control:
      
      집계 제어에 사용할 수있는 단일 서버의 여러 스트림으로 구성된 프리젠 테이션입니다. 이러한 설명은 일반적으로 URL의 DESCRIBE 요청에 대한 응답으로 리턴되거나 ANNOUNCE 메소드로 수신됩니다.

이 부록에서는 예를 들어 HTTP를 통해 검색된 SDP 파일이 RTSP 세션의 작동을 결정하는 방법에 대해 설명합니다. 또한 클라이언트가 DESCRIBE 요청에 대한 응답으로 리턴 된 SDP 컨텐츠를 해석하는 방법을 설명합니다. SDP는 클라이언트가 사람의 안내없이 동시에 렌더링 할 여러 미디어 스트림과 여러 대안 (예 : 서로 다른 언어로 말하는 두 개의 오디오 스트림)을 구별 할 수있는 메커니즘을 제공하지 않습니다.
<hr/>

#### C.1 Definitions
이 부록에 사용 된 용어 "세션 수준", "미디어 수준"및 기타 키 / 속성 이름 및 값은 SDP (RFC 2327 [6])에 정의 된대로 사용됩니다.

#### C.1.1 Control URL

"a = control :"속성은 제어 URL을 전달하는 데 사용됩니다. 이 속성은 세션 및 미디어 설명에 모두 사용됩니다. 개별 미디어에 사용되는 경우 해당 특정 미디어 스트림을 제어하는 데 사용되는 URL을 나타냅니다. 세션 레벨에서 발견되면 속성은 집계 제어를위한 URL을 나타냅니다.

      Example:
            a=control:rtsp://example.com/foo

이 속성은 RFC 1808 [25]에 규정 된 규칙과 규칙에 따라 상대 URL과 절대 URL을 포함 할 수 있습니다. 구현시 다음 순서로 기본 URL을 찾아야합니다.    

1. RTSP 컨텐츠 기반 필드    
2. RTSP 컨텐츠 위치 필드    
3. RTSP 요청 URL

이 속성에 별표 (*) 만 포함 된 경우 URL은 비어있는 내장 URL 인 것처럼 취급되므로 전체 기본 URL을 상속합니다.
<hr/>


#### C.1.2 Media streams
"m ="필드는 스트림을 열거하는 데 사용됩니다. 지정된 모든 스트림이 적절한 동기화로 렌더링 될 것으로 예상됩니다. 세션이 유니 캐스트 인 경우 포트 번호는 서버에서 클라이언트로의 추천으로 사용됩니다. 클라이언트는 여전히 SETUP 요청에 클라이언트를 포함시켜야하며이 권장 사항을 무시할 수 있습니다. 서버에 기본 설정이 없으면 포트 번호 값을 0으로 설정해야합니다.

      Example:
            m=audio 0 RTP/AVP 31
<hr/>


#### C.1.3 Payload type(s)

페이로드 유형은 "m ="필드에 지정됩니다. 페이로드 유형이 RFC 1890 [1]의 정적 페이로드 유형 인 경우 다른 정보는 필요하지 않습니다. 동적 페이로드 유형 인 경우    미디어 속성 "rtpmap"은 미디어가 무엇인지 지정하는 데 사용됩니다. "rtpmap"속성 내의 "인코딩 이름"은 RFC 1890 (섹션 5 및 6)에 지정된 것 중 하나이거나 SDP (RFC 2327 [6])에 지정된 "X-"접두어가있는 실험용 인코딩 일 수 있습니다. 코덱 별 매개 변수는이 필드에 지정되지 않고 아래 설명 된 "fmtp"속성에 지정됩니다. 새로운 인코딩을 등록하려는 구현자는 RFC 1890 [1]의 절차를 따라야합니다.    미디어 유형이 RTP AV 프로파일에 적합하지 않은 경우 "m ="필드에서 "RTP / AVP"대신 새 프로파일을 작성하고 적절한 프로파일 이름을 사용하는 것이 좋습니다.
<hr/>

#### C.1.4 Format-specific parameters

형식 별 매개 변수는 "fmtp"매체 속성을 사용하여 전달됩니다. "fmtp"속성의 구문은 속성이 참조하는 인코딩에 따라 다릅니다. 패킷 화 간격은 "ptime"속성을 사용하여 전달됩니다.

#### C.1.5 Range of presentation

"a = range"속성은 저장된 세션의 총 시간 범위를 정의합니다. 라이브 세션의 길이는 "t"및 "r"매개 변수에서 추론 할 수 있습니다. 프리젠 테이션에 길이가 다른 미디어 스트림이 포함되지 않은 경우 range 속성은 세션 레벨 속성입니다. 단위가 먼저 지정된 다음 값 범위가 지정됩니다.    단위와 그 값은 3.5, 3.6 및 3.7에 정의되어 있습니다.
~~~
   Examples:
     a=range:npt=0-34.4368
     a=range:clock=19971113T2115-19971113T2203
~~~
<hr/>

#### C.1.6 Time of availability

"t ="필드는 집계 및 비 집계 스트림 제어의 시작 및 중지 시간에 적합한 값을 포함해야합니다. 집계 제어를 사용하면 서버는 설명이 유효하다는 것을 보장하는 중지 시간 값과 DESCRIBE 요청을받은 시간과 같거나 그 전에 시작 시간을 표시해야합니다 (SHOULD). 또한 시작 및 중지 시간이 0임을 나타낼 수도 있습니다. 즉, 세션을 항상 사용할 수 있습니다. 비 집계 제어를 사용하면 값이 SDP 의미를 유지하면서 세션을 사용할 수있는 실제 기간을 반영해야하며이를 위해 다른 방법 (예 : 설명이 포함 된 웹 페이지의 수명)에 의존해서는 안됩니다.
<hr/>

#### C.1.7 Connection Information

SDP에서 "c ="필드에는 미디어 스트림의 대상 주소가 포함됩니다. 그러나 주문형 유니 캐스트 스트림 및 일부 멀티 캐스트 스트림의 경우 대상 주소는 SETUP 요청을 통해 클라이언트에 의해 지정됩니다. 미디어 컨텐츠에 고정 목적지 주소가 없으면 "c ="필드는 적절한 널값으로 설정됩니다. "IP4"유형의 주소의 경우이 값은 "0.0.0.0"입니다.
<hr/>

  #### C.1.8 Entity Tag

선택적 "a = etag"속성은 세션 설명의 버전을 식별합니다. 클라이언트에게 불투명합니다. SETUP 요청은 If-Match 필드 (12.22 참조)에이 식별자를 포함하여이 속성 값이 여전히 현재 설명의 속성 값과 일치하는 경우 세션 설정 만 허용합니다. 속성 값은 불투명하며 SDP 속성 값 내에 허용되는 모든 문자를 포함 할 수 있습니다.

      Example:
            a=etag:158bb3e7c7fd62ce67f12b533f06b83a

"o ="필드가 동일한 기능을 제공한다고 주장 할 수 있습니다. 그러나 동일한 미디어 컨텐츠에 대해 SDP 이외의 여러 세션 설명 유형을 지원해야하는 서버에 제한을 두는 방식으로 그렇게합니다.
<hr/>

#### C.2 Aggregate Control Not Available

프레젠테이션이 집계 제어를 지원하지 않고 여러 미디어 섹션이 지정된 경우 각 섹션에는 "a = control :"속성을 통해 지정된 제어 URL이 있어야합니다.
~~~
   Example:
     v=0
     o=- 2890844256 2890842807 IN IP4 204.34.34.32
     s=I came from a web page
     t=0 0
     c=IN IP4 0.0.0.0
     m=video 8002 RTP/AVP 31
     a=control:rtsp://audio.com/movie.aud
     m=audio 8004 RTP/AVP 3
     a=control:rtsp://video.com/movie.vid
~~~

설명에서 제어 URL의 위치는 클라이언트가 audio.com 및 video.com 서버에 대해 별도의 RTSP 제어 세션을 설정 함을 의미합니다.    

RDP 이외의 수단을 통해 미디어 클라이언트에 전달 되더라도 SDP 파일에는 전체 미디어 초기화 정보가 포함되는 것이 좋습니다. 이는 클라이언트가 DESCRIBE를 통해보다 자세한 미디어 스트림 정보를 요청해야한다는 것을 나타내는 메커니즘이 없기 때문에 필요합니다.
<hr/>

#### C.3 Aggregate Control Available
이 시나리오에서 서버에는 전체적으로 제어 할 수있는 여러 스트림이 있습니다. 이 경우 스트림 URL을 지정하는 데 사용되는 미디어 레벨 "a = control :"속성과 집계 제어를위한 요청 URL로 사용되는 세션 레벨 "a = control :"속성이 있습니다. 미디어 수준 URL이 상대적인 경우 위의 C.1.1 절에 따라 절대 URL로 확인됩니다.    

프리젠 테이션이 단일 스트림만을 포함하는 경우, 미디어 레벨 "a = control :"속성은 모두 생략 될 수있다. 그러나 프레젠테이션에 둘 이상의 스트림이 포함 된 경우 각 미디어 스트림 섹션에는 자체 "a = control"속성이 포함되어야합니다.
~~~
   Example:
     v=0
     o=- 2890844256 2890842807 IN IP4 204.34.34.32
     s=I contain
     i=<more info>
     t=0 0
     c=IN IP4 0.0.0.0
     a=control:rtsp://example.com/movie/
     m=video 8002 RTP/AVP 31
     a=control:trackID=1
     m=audio 8004 RTP/AVP 3
     a=control:trackID=2
~~~

이 예에서 클라이언트는 서버에 단일 RTSP 세션을 설정해야하며 URL 

      rtsp : //example.com/movie/trackID=1 및 
      rtsp : //example.com/movie/trackID=2
를 사용합니다. 비디오 및 오디오 스트림을 각각 설정하십시오. 
      
      URL rtsp : //example.com/movie/는 전체 영화를 제어합니다.
<hr/>

#### Appendix D: Minimal RTSP implementation

#### D.1 Client
클라이언트 구현은 반드시 다음을 수행 할 수 있어야합니다.      
* SETUP, TEARDOWN 및 PLAY (최소 재생 클라이언트) 또는 RECORD (최소 녹화 클라이언트) 중 하나의 요청을 생성하십시오. RECORD가 구현되면 ANNOUNCE도 구현해야합니다.      
* 요청에 CSeq, 연결, 세션, 전송 헤더를 포함시킵니다. ANNOUNCE가 구현되면 Content-Language, Content-Encoding, Content- Length 및 Content-Type 헤더를 포함하는 기능도 있어야합니다.      응답에서 CSeq, 연결, 세션, 전송, 컨텐츠 언어, 컨텐츠 인코딩, 컨텐츠 길이, 컨텐츠 유형 헤더를 구문 분석하고 이해하십시오. RECORD가 구현되면 Location 헤더도 이해해야합니다. RTP 호환 구현은 RTP-Info도 구현해야합니다.      
* 수신 된 각 오류 코드의 클래스를 이해하고 존재하는 경우 최종 사용자에게 클래스 4xx 및 5xx의 오류 코드를 알립니다. 최종 사용자가 명시 적으로 하나 또는 모든 상태 코드에 대해 원하지 않는 경우 알림 요구 사항이 완화 될 수 있습니다.      
* ANNOUNCE와 같은 서버의 비동기 요청을 예상하고 응답합니다. 이것이 반드시 ANNOUNCE 메소드를 구현해야한다는 것을 의미하는 것은 아니며, 단지 서버로부터받은 요청에 대해 긍정적 또는 부정적으로 응답해야한다는 것입니다.    필수 사항은 아니지만, 초기 구현과의 실질적인 상호 운용성 및 / 또는 "좋은 시민"이되기 위해서는 출판 당시 다음 사항을 적극 권장합니다.     
* RTP / AVP / UDP를 유효한 전송 수단으로 구현하십시오.      
* User-Agent 헤더 포함.      
* 부록 C에 정의 된 SDP 세션 설명 이해      
* 표준 입력, 명령 줄 또는 운영 환경에 적합한 기타 수단 (예 : 웹 브라우저)의 "도우미 응용 프로그램"으로 작동하는 미디어 초기화 형식 (예 : SDP)을 받아들입니다.      

위에서 언급 한 요구 사항이 적합하지 않은 RTSP 사양에 기고자가 처음 계획 한 것과는 다른 RTSP 응용 프로그램이있을 수 있습니다. 따라서 위의 권장 사항은 엄격한 요구 사항 대신 지침으로 만 사용됩니다.
<hr/>
  
#### D.1.1 Basic Playback
미디어 스트림의 주문형 재생을 지원하려면 클라이언트가 추가로 다음을 수행 할 수 있어야합니다.      
* PAUSE 요청을 생성;      
* REDIRECT 메소드와 Location 헤더를 구현하십시오.
<hr/>

#### D.1.2 Authentication-enabled

인증이 필요한 RTSP 서버에서 미디어 프리젠 테이션에 액세스하려면 클라이언트가 추가로 다음을 수행 할 수 있어야합니다.      
* 401 상태 코드를 인식합니다.      
* WWW-Authenticate 헤더를 구문 분석하고 포함합니다.      
* 기본 인증 및 다이제스트 인증을 구현하십시오.
<hr/>

#### D.2 Server
최소한의 서버 구현은 다음을 수행 할 수 있어야합니다.      
* SETUP, TEARDOWN, OPTIONS 및 PLAY (최소 재생 서버의 경우) 또는 RECORD (최소 녹화 서버의 경우) 방법을 구현하십시오. RECORD가 구현되면 ANNOUNCE도 구현해야합니다.      
* 응답에 연결, 컨텐츠 길이, 컨텐츠 유형, 컨텐츠 언어, 컨텐츠 인코딩, 전송, 공용 헤더를 포함하십시오. RECORD 메소드가있는 경우 Location 헤더를 포함하는 기능을 구현해야합니다. RTP 호환 구현은 RTP 정보 필드도 구현해야합니다.      
* 요청에서 연결, 세션, 전송, 필요 등의 헤더를 구문 분석하고 적절히 응답    필수 사항은 아니지만, 초기 구현과의 실질적인 상호 운용성 및 / 또는 "좋은 시민"이되기 위해서는 출판 당시 다음 사항을 적극 권장합니다.      
* RTP / AVP / UDP를 유효한 전송 수단으로 구현하십시오.      
* 서버 헤더 포함.      
* DESCRIBE 방법을 구현하십시오.      
* 부록 C에 정의 된대로 SDP 세션 설명 생성      
위에서 언급 한 요구 사항이 적합하지 않은 RTSP 사양에 기고자가 처음 계획 한 것과는 다른 RTSP 응용 프로그램이있을 수 있습니다. 따라서 위의 권장 사항은 엄격한 요구 사항 대신 지침으로 만 사용됩니다.
<hr/>

#### D.2.1 Basic Playback
미디어 스트림의 주문형 재생을 지원하려면 서버가 추가로 다음을 수행 할 수 있어야합니다.      
* Range 헤더를 인식하고 탐색이 아닌 경우 오류를 반환        지원됩니다.      
* PAUSE 방법을 구현하십시오.    
또한 일반적으로 수용되는 사용자 인터페이스 기능을 지원하려면 주문형 미디어 서버에 다음을 적극 권장합니다.      
* NPT 단위로 Range 헤더를 포함하고 구문 분석하십시오. SMPTE 장치의 구현이 권장됩니다.      
* 미디어 초기화 정보에 미디어 프레젠테이션 길이를 포함 시키십시오.      
* 데이터 별 타임 스탬프에서 NPT 로의 매핑을 포함합니다. RTP가 사용될 때, RTP-Info 필드의 rtptime 부분은 RTP 타임 스탬프를 NPT에 매핑하는데 사용될 수있다.      
클라이언트 구현은 길이 정보의 존재를 사용하여 클립이 검색 가능한지 여부를 결정하고, 길이 정보를 사용할 수없는 클립의 검색 기능을 눈에 띄게 비활성화 할 수 있습니다.      
프레젠테이션 길이의 일반적인 용도는 진행률 표시기 및 타임 라인 위치 지정 도구 역할을하는 "슬라이더 막대"를 구현하는 것입니다.    

슬라이더 막대를 올바르게 배치하려면 RTP 타임 스탬프에서 NPT로 매핑해야합니다.
<hr/>


#### D.2.2 Authentication-enabled
클라이언트 인증을 올바르게 처리하려면 서버에서 다음을 추가로 수행 할 수 있어야합니다.      
* 자원에 대한 인증이 필요한 경우 401 상태 코드를 생성하십시오.      
* WWW-Authenticate 헤더 구문 분석 및 포함      
* 기본 인증 및 다이제스트 인증 구현
